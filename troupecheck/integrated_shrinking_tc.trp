import lists  
(* 
--------------------------------
PRINTING TO CONSOLE - q
-------------------------------- 
*)
let val out = getStdout authority
    fun write x = fwrite (out, x)
    (* arguments are always in a list - for easier readability these are removed when converting arguments to string *)
    fun args_toString args = 
        let fun aux_toString acc (x0::x1::xs) = aux_toString (acc ^ (toString x0) ^ ", ") (x1::xs)
            | aux_toString acc (x::xs) = acc ^ (toString x) in 
        aux_toString "" args end
(* 
--------------------------------
ERROR HANDLING - w
-------------------------------- 
*)
    fun report_error error_reason = 
        write "\u001B[31m \nError: "; (* Changing the print color to red *)
        let val err_string = case error_reason of 
            ("cant_generate", tries) => "Couldn't produce an instance that satisfies all strict constraints after "
                                            ^ (toString tries) ^ " tries.\n"
            | ("cant_satisfy", tries) => "No valid test could be generated after " ^ (toString tries) ^ " tries.\n"
            | ("non_boolean_result", _) => "The property or precondition code returned a non-boolean result.\n"
            | ("type_mismatch", _) => "The types' structure doesn't match the property.\n"
            | ("illegal_gen_def", _ ) => "Generator is defined wrong - use tuple() or record() to combine generators.\n"
            | ("record_mismatch", _) => "the number of names provided for record generation, does not match the number of types provided.\n"
            | ("shrinking_looped", _) => "Shrinking looped.\n"
            | ("non_string_type", _) => "An element of non-string type found when trying to convert list to string.\n"
        in
        write (err_string ^ "\u001B[0m"); (* Changing the color back *)
        exit (authority, 0) end
    
    fun boolean_check x = 
        if (getType x)<>"boolean" then report_error ("non_boolean_result", 0) else ()

    fun function_not_done_check p = 
        if (getType p)<>"function" then report_error ("type_mismatch", 0) else ()
(*
--------------------------------
UTILS - e
-------------------------------- 
*)  
    fun remove_nth n [] i = []
    | remove_nth n (x::xs) i = 
        if n = i then xs
        else x :: (remove_nth n xs (i + 1))
    
    fun make_list (f, i) = 
    case i of 
    0 => []
    | _ => append [f()] (make_list (f, i-1))
    
    fun abs_value x = 
    if x < 0 then -x else x 

(* applies the list of arguments to the property - one by one - reporting errors along the way *)
(* TODO: handle when arguments are passed to a property that does not take arguments *)
    fun apply_args p l =
        case l of 
            [] => boolean_check (p()); p() (* this case is only reached if there are no generators to beign with*)
            | (x::xs) => 
                let val res = foldl (fn (x,y) => function_not_done_check y; y x) p l in
                boolean_check res;
                res 
                end
    
    fun string_to_list s = 
        let fun aux "" acc = acc 
            | aux s acc = 
                let val x = substring (s, 0, 1)
                    val xs = substring (s, 1, 1/0) in 
                aux xs (append acc [x]) end in 
        aux s [] end
    
    fun list_to_string ls = 
        foldl (fn (x,y) => if getType x <> "string" then report_error ("non_string_type", 0) else y ^ x) "" ls
    
    fun string_length s = 
        length (string_to_list s)

    fun report_fail_reason rec noOfTests= 
        case rec.failReason of
            "false_prop" => 
                write "\nFailure at input: ";
                write (args_toString (map (fn x => x.raw) rec.cEx));
                write ("\nAfter running: " ^ (toString (noOfTests - rec.remTests + 1)) ^ " test(s)\n")
    
    fun build_record names vals = 
        let fun aux r [] [] = r 
            | aux r (n::ns) (v::vs) = 
                aux (recordExtend(r, n, v)) ns vs in
        aux {} names vals 
        end
    
    fun build_tuple ls = 
                case ls of 
                [] => (0)
                |[x] => (x) 
                |[x1,x2] => (x1,x2)
                |[x1,x2,x3] => (x1,x2,x3)
                |[x1,x2,x3,x4] => (x1,x2,x3,x4)
                |[x1,x2,x3,x4,x5] => (x1,x2,x3,x4,x5)
                |[x1,x2,x3,x4,x5,x6] => (x1,x2,x3,x4,x5,x6)
                |[x1,x2,x3,x4,x5,x6,x7] => (x1,x2,x3,x4,x5,x6,x7)
                |[x1,x2,x3,x4,x5,x6,x7,x8] => (x1,x2,x3,x4,x5,x6,x7,x8)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9] => (x1,x2,x3,x4,x5,x6,x7,x8,x9)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10] => (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
                |_ => (2, 3, 4, 5) 
(* 
--------------------------------
SHRINKING - t
-------------------------------- 
*)  
    
    and shrink_float rec = 
        let val rec_checked = if rec.curr = 0 then {rec with state = "done"} else rec 
            val curr_val = rec_checked.curr 
        in 
        case rec_checked.state of 
        "rollback" => 
            {state = "done", curr = rec_checked.prev, prev = rec_checked.curr}
        |"done" => 
            rec_checked
        | _ => 
            let val new_raw_val = if (abs_value curr_val)-1 <= 0 then 0 else curr_val/2 
            in 
            {state = "cont", curr = new_raw_val, prev = rec_checked.curr} 
            end 
        end
    
    and shrink_int rec = 
        let val interim = shrink_float rec 
        in 
        {interim with curr = floor(interim.curr)} 
        end
    
    and shrink_bool rec = 
        let val rec_checked = if rec.curr = false then {rec with state = "done"} else rec 
        in 
        case rec_checked.state of 
        "rollback" => 
            {state = "done", curr = rec_checked.prev, prev = rec_checked.curr}
        |"done" => 
            rec_checked
        | _ => 
            let val newVal = false  
            in
            {state = "cont", curr = newVal, prev = rec_checked.curr} 
            end 
        end
    
    (* input/returns - {state: string, curr: string, prev: string} *)
    and shrink_string rec = 
        let val rec_checked = if rec.state = "init" then {rec with next_shrink_info = 0} else rec in
        case rec_checked.state of 
        "cont_elem" => 
            {rec_checked with state = "done"} (* TODO: Should actually shrink characters *)
        | _ =>
            let val ls_curr = string_to_list rec_checked.curr
                val ls_prev = string_to_list rec_checked.prev
                val shrinkers = map (fn _ => shrink_char) ls_curr   

                val interim_res = shrink_list shrinkers {state = rec_checked.state, curr = ls_curr, prev = ls_prev, idx = rec_checked.next_shrink_info} 
                val new_curr = list_to_string interim_res.curr
                val new_prev = list_to_string interim_res.prev

                val res = {state = interim_res.state, curr = new_curr, prev = new_prev, next_shrink_info = interim_res.idx} 
            in
                res 
            end
        end

        
    and shrink_char rec = 
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val rec_checked = if rec.curr = "a" then {rec with state = "done"} else rec 
            val curr_val = rec_checked.curr in
        case rec_checked.state of 
        "rollback" =>
            {state = "done", curr = rec.prev, prev = rec.curr, idx = rec.idx}
        | "done" =>
            rec_checked
        | "init" => 
            let val index_of_new = (lookup chars rec.curr 2) - 1
                val new_char = nth chars index_of_new 
            in 
                {state = "cont", curr = new_char, prev = rec.curr, idx = index_of_new}
            end
        | _ =>
            let val index_of_new = rec.idx-1
                val new_char = nth chars index_of_new 
            in 
                {state = "cont", curr = new_char, prev = rec.curr, idx = index_of_new}
            end
        end


    and shrink_rec names vals rec = 
        case rec.state of 
            "rollback" =>
                let fun rollback_aux (i, x) = 
                        let val val_to_shrink = {(nth rec.next_shrink_info (i+1)) with state = "rollback"}
                        in 
                            x.shrinker val_to_shrink 
                        end 
                    val args_rolled_back = mapi rollback_aux vals
                    val new_raw_vals = map (fn x => x.curr) args_rolled_back
                    val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true args_rolled_back) then "done" else "cont"
                in 
                    {state = new_state, curr = (build_record names new_raw_vals), prev = rec.curr, next_shrink_info = args_rolled_back}
                end
            | "init" => 
                let val new_vals = mapi (fn (i, x) => x.shrinker {state = "init", curr = x.raw, prev = x.raw}) vals
                    val new_raw_vals = map (fn x => x.curr) new_vals
                    val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true new_vals) then "done" else "cont"
                in 
                    {state = new_state, curr = (build_record names new_raw_vals), prev = rec.curr, next_shrink_info = new_vals}
                end

            | "done" => 
                rec
            | _ => 
                let val new_vals = mapi (fn (i, x) => x.shrinker (nth rec.next_shrink_info (i+1))) vals
                    val new_raw_vals = map (fn x => x.curr) new_vals
                    val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true new_vals) then "done" else "cont"
                in 
                    {state = new_state, curr = (build_record names new_raw_vals), prev = rec.curr, next_shrink_info = new_vals}
                end

    (* input - vals: list, rec: {state: string, curr: tuple, prev: tuple} 
    returns - {state: string, curr: tuple, prev: tuple, next_shrink_info: list} *)
    and shrink_tuple shrinkers rec = 
        case rec.state of 
        "done" => 
            rec 
        | "rollback" => 
            let val args_rolled_back = mapi (fn (i, x) => x {state = "rollback", curr = rec.curr.i, prev = rec.prev.i}) shrinkers
                val new_raw_vals = map (fn x => x.curr) args_rolled_back
                val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true args_rolled_back) then "done" else "cont"
            in 
                {state = new_state, curr = (build_tuple new_raw_vals), prev = rec.curr, next_shrink_info = args_rolled_back}
            end
        | "init" =>
            let val new_vals = mapi (fn (i, x) => x {state = "init", curr = rec.curr.i, prev = rec.prev.i}) shrinkers
                val new_raw_vals = map (fn x => x.curr) new_vals
                val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true new_vals) then "done" else "cont"
            in 
                {state = new_state, curr = (build_tuple new_raw_vals), prev = rec.curr, next_shrink_info = new_vals}
            end
        | "cont" =>
            let val new_vals = mapi (fn (i, x) => x (nth rec.next_shrink_info (i+1))) shrinkers
                val new_raw_vals = map (fn x => x.curr) new_vals
                val new_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true new_vals) then "done" else "cont"
            in 
                {state = new_state, curr = (build_tuple new_raw_vals), prev = rec.curr, next_shrink_info = new_vals}
            end
    
    and shrink_list shrinkers rec  = 
        if (rec.curr = []) andalso (rec.state <> "rollback") then {rec with state = "done", prev = rec.curr, idx = 0}
        else 
            case rec.state of 
            "init" => 
                let val removeIdx = (length (rec.curr)) - 1
                    val newList = remove_nth removeIdx rec.curr 0 
                in 
                    {state = "cont_size", curr = newList, prev = rec.curr, idx = removeIdx} 
                end
            | "cont_size" => 
                let val remove_idx = (rec.idx - 1)
                    val next_state = if remove_idx <= 0 then "cont_elem" else "cont_size"
                    val new_list = remove_nth remove_idx rec.curr 0 
                in  
                    {state = next_state, curr = new_list, prev = rec.curr, idx = remove_idx} 
                end
            | "cont_elem" => 
                (* TODO: give list of shrinkers in the list_gen rec.curr should be list of raw elements *)
                let val interim_list = mapi (fn (i, x) => (nth shrinkers (i+1)){state = "init", curr = x, prev = x}) rec.curr
                    val next_state = if (foldl (fn (x,y) => (x.state = "done") andalso y) true interim_list) then "done" else "cont_elem"
                    val new_list = map (fn x => x.curr) interim_list 
                in
                    {state = next_state, curr = new_list, prev = rec.curr, idx = rec.idx} 
                end
            | "rollback" => 
                if (length rec.curr) = (length rec.prev) then 
                    {state = "done", curr = rec.prev, prev = rec.curr, idx = rec.idx} (* TODO: this loops an unecesary amount of times *)
                else 
                    {state = "cont_size", curr = rec.prev, prev = rec.curr, idx = rec.idx}
            | "done" => 
                rec

    and args_shrink args = 
        case args.state of 
        "rollback" => 
            let val rollbackReadyArgs = map (fn x => if x.state = "done" then x else {x with state = "rollback"}) args.args
                val argsRolledBack = mapi (fn (i, x) => (nth args.shrinkers (i+1)) x) rollbackReadyArgs in 
            {state = "cont", args = argsRolledBack, shrinkers = args.shrinkers} end
        | _ => 
            let val newArgs = mapi (fn (i, x) => (nth args.shrinkers (i+1)) x) args.args
                val nextState = if (foldl (fn (x,y) => (x.state = "done") andalso y) true newArgs) then "done" else "cont" in 
            {state = nextState, args = newArgs, shrinkers = args.shrinkers} end

    fun shrink_aux args prop pre counter = 
        if counter = 100 then report_error ("shrinking_looped", 0) else
        let val shrunk_args = args_shrink args  
            val shrunk_args_raw = map (fn x => x.curr) shrunk_args.args 
            val precond_is_met = if (pre <> ()) then (apply_args pre shrunk_args_raw) else true in
        case (apply_args prop shrunk_args_raw) orelse (precond_is_met = false) of
            true => shrink_aux (args_shrink {state = "rollback", args = shrunk_args.args, shrinkers = args.shrinkers}) prop pre (counter)
            | false =>
                if shrunk_args.state = "done" then {shrunk_ctx = shrunk_args_raw, count = counter} else shrink_aux shrunk_args prop pre (counter+1) end

    fun shrink args prop pre = 
        let val shrinkers = map (fn x => x.shrinker) args
            val args_shrink_ready = map (fn x => {state = "init", curr = x.raw, prev = x.raw}) args
            val args_rec = {state = "init", args = args_shrink_ready, shrinkers = shrinkers}
            val res = shrink_aux args_rec prop pre 0 
        in res end
(*
--------------------------------
GENERATORS - r
-------------------------------- 
*)  
    (* return - {raw: bool, shrinker: fn {state: string, curr: bool, prev: bool} => ..: {state: string, curr: bool, prev: bool}} *)
    fun bool_gen size = 
        let val rnd = random() 
            val res =  if rnd < 1/2 then false
                       else true 
        in
            {raw = res, shrinker = shrink_bool} 
        end

    (* return - {raw: number, shrinker: fn {state: string, curr: number, prev: number} => ..: {state: string, curr: number, prev: number}} *)
    (* TODO: Fix shrinking towards zero -> should shrink towards lowest valid val *)
    fun float_gen (low, high) size = 
        let val x = random() 
            val lInf = low = 1/0 (* check for inf *)
            val hInf = high = 1/0
            val raw_res = 
                case (lInf, hInf) of 
                    (true, true) => if (bool_gen size).raw then x*size else -x*size
                    | (true, false) => high - (x*size) 
                    | (false, true) => low + (x*size)
                    | (false, false) => low + (x * (high-low)) 
        in 
            {raw = raw_res, shrinker = shrink_float}
        end

    (* return - {raw: number, shrinker: fn {state: string, curr: number, prev: number} => ..: {state: string, curr: number, prev: number}} *)
    fun int_gen (low, high) size = 
        let val raw_res = floor ((float_gen(low, high) size).raw) 
        in 
            {raw = raw_res, shrinker = shrink_int}
        end

    (* return - {raw: list, shrinker: fn {state: string, curr: list, prev: list} => ..: {state: string, curr: list, prev: list}} *)
    fun list_gen (generator) size = 
        let val length = (int_gen(0, size) size).raw 
            val res = make_list ((fn () => generator size), length) 
            val raw_res = map (fn x => x.raw) res 
            val shrinkers = map (fn x => x.shrinker) res in 
        {raw = raw_res, shrinker = shrink_list shrinkers} 
        end

    (* NOTE: Generates only letters (upper and lower case) and numbers. *)
    (* return - {raw: char, shrinker: fn {state: string, curr: char, prev: char} => ..: {state: string, curr: char, prev: char}} *)
    fun char_gen size =
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val x = (int_gen (1, ((length chars)-1)) size).raw
        in 
            {raw = (nth chars x), shrinker = shrink_char} 
        end

(* NOTE: Generates only strings of letters (upper and lower case) and numbers. *)
    (* return - {raw: string, shrinker: fn {state: string, curr: string, prev: string} => ..: {state: string, curr: string, prev: string}} *)
    fun string_gen size = 
        let val x = (int_gen (0, size) size).raw
            fun fold f acc 0 = acc 
            | fold f acc i = fold f (acc ^ (f())) (i-1) 
            val raw_string = (fold (fn () => (char_gen x).raw) "" x)
        in  
            {raw = raw_string, shrinker = shrink_string} 
        end

(* NOTE: Hardcoded for tuple of up to 10 elements *)
(* returns a record with raw_inst: a tuple of whatever values specified, and meta_data is a list 
    of all generated values in raw_inst along with their respective meta_data. *)
    fun tuple_gen ts size = 
        let val ts_vals = map (fn x => x size) ts
            val ts_raw_vals = map (fn x => x.raw) ts_vals 
            val ts_shrinkers = map (fn x => x.shrinker) ts_vals
        in
            {raw = (build_tuple ts_raw_vals), shrinker = shrink_tuple ts_shrinkers} 
        end

(* 
ns: list of strings - will be used as fieldnames
ts: list of generators - used to generate values for fields 

Returns record: {raw_inst = <<actual result record>>, meta_data = (ns, <<list of all generated values for record with respective meta_data>>)}
*)    
    fun rec_gen ns ts size = 
        if (length ns) <> (length ts) then 
            report_error ("record_mismatch", 0)
        else 
            let val ts_vals = map (fn x => x size) ts
                val ts_raw_vals = map (fn x => x.raw) ts_vals  
                val raw_res = build_record ns ts_raw_vals 
            in
                {raw = raw_res, shrinker = shrink_rec ns ts_vals}
            end 


    fun generator_gen size = 
        let val rnd = random()
            val inf = 1/0
            val res = if rnd <= 1/7 then ((fn i => int_gen(inf, inf) i)) else 
                      if rnd <= 2/7 then ((fn i => bool_gen i)) else 
                      if rnd <= 3/7 then ((fn i => float_gen(inf, inf) i)) else
                      if rnd <= 4/7 then ((fn i => string_gen i)) else
                      if rnd <= 5/7 then ((fn i => char_gen i)) else
                      if rnd <= 6/7 then ((fn i => tuple_gen (make_list ((fn () => int_gen(inf, inf)), i)) i)) else
                     ((fn i => list_gen (int_gen(inf, inf)) i)) in
        res end
        
(* 
--------------------------------
CORE FUNCTIONALITY - a
-------------------------------- 
*)              
    fun core_forall (generator, prop, 0, size, pre, cap) = {failReason = (), cEx = (), remTests = 0}
        |core_forall (generator, prop, i, size, pre, cap) =  
            let val args = map (fn x => x size) generator 
                val raw_args = map (fn x => x.raw) args in
            case pre of 
                () => 
                    if (apply_args prop raw_args) then (write "."; core_forall (generator, prop, i-1, size+1, pre, cap))
                    else (write "!"; {failReason = "false_prop", cEx = args, remTests = i})
                | _ => 
                    if (apply_args pre raw_args) then 
                        if (apply_args prop raw_args) then (write "."; core_forall (generator, prop, i-1, size+1, pre, cap))
                        else (write "!"; {failReason = "false_prop", cEx = args, remTests = i})
                    else 
                    (write "x"; 
                    if (size = cap) andalso (i*5 = cap) then report_error ("cant_satisfy", size)
                    else if size = cap then {failReason = (), cEx = (), remTests = i}
                    else core_forall (generator, prop, i, size+1, pre, cap))
            end

    fun tc_n generators p noOfTests = 
        let val (prop, pre) = 
                case p of    
                    (x,y) => (x,y)
                    | x => (x, ())
            val res = core_forall (generators, prop, noOfTests, 0, pre, (noOfTests*5)) in 
            case res.failReason of
                () => write ("\u001B[1m \u001B[32m \nSuccess: \u001B[0mPassed all " ^ (toString noOfTests) ^ " test(s).\n"); true
                |_ => 
                    report_fail_reason res noOfTests; 
                    write ("\u001B[1m\u001B[34mShrinking\u001B[0m:");
                    let val shrink_res = shrink res.cEx prop pre in
                    write "\nFailing test case was shrunk to:\n";
                    write (args_toString shrink_res.shrunk_ctx);
                    write ("\nAfter " ^ (toString shrink_res.count) ^ " iterations.\n");
                    false
                    end
        end
    
    fun tc generator p = tc_n generator p 100

    fun troupecheck generator p noOfTests = spawn (fn() => tc_n generator p noOfTests)
    | troupecheck generator p = spawn (fn() => tc generator p)

(* 
--------------------------------
CONVENIENCE FUNCTIONS - s
-------------------------------- 
*)
    val inf = 1 / 0
    fun integer() = int_gen(inf, inf)
        | integer (h, l) = int_gen(h, l)
    
    fun pos_integer() = integer(0, inf)

    fun neg_integer() = integer(inf, -1)

    fun float() = float_gen(inf, inf)
        | float(h, l) = float_gen(h, l)

    fun pos_float() = float(0, inf)

    fun neg_float() = float(inf, 0)

    fun boolean() = bool_gen

    fun list() = list_gen(generator_gen()) (* TODO: generator_gen() should return both raw_gen and meta_data *)
        |list(type) = list_gen(type)

    fun string() = string_gen

    fun char() = char_gen

    fun tuple ts = tuple_gen ts
    
    fun record ns ts = rec_gen ns ts
        
    
(* 
--------------------------------
FUNCTIONS FOR TESTING - d
-------------------------------- 
*) 
    fun my_reverse xs = 
        xs
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1

    fun my_length [] = 0
        | my_length (x::xs) = 1 + (my_length xs)

    fun my_count y [] = 0
        | my_count y (x::xs) = 
            let val z = 
                if y = x then 1 else 0 
            in 
            z + my_count y xs end 
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1
    
    fun my_ceil_1 i =
        if i > 0 then i + (1 - (i mod 1))
        else i + (1 - (i mod 1)) - 1
    
    fun my_ceil_2 i =
        if i > 0 then (my_floor i) + 1
        else if i = 0 then 0
        else (my_floor i) + 1
    
    fun bad_insert xs x = 
        if length xs < 10 then append [x] xs else
        xs

    fun one_of_two (x, y) =
        let val bool = (bool_gen 0).raw in
        if bool then x
        else y end    
    
    fun bad_half n = 
        if n > 10 then n else n/2

    fun lengths_not_same s1 s2 = 
        (string_length s1) <> (string_length s2)    
    
(*
--------------------------------
PROPERTIES FOR TESTING - f
-------------------------------- 
*)
    fun bool_commutative x y = 
        (x andalso y) = (y andalso x)
    
    fun number_commutative x y = 
        x * y = y * x

    fun list_reverse xs = 
        reverse(reverse xs) = xs
    
    fun int_gen_stays_in_interval i = 
        (integer(0, i) i).raw <= i
    
    fun abs_value_is_always_pos i =
        abs_value i >= 0
    
    fun my_floor_test i =
        my_floor i = floor i

    fun my_length_test xs = 
        my_length xs = length xs
    
    fun make_list_test i = 
        let val generator = generator_gen i
            fun f() = generator ((int_gen(0, inf) i).raw) 
            val ls = (make_list (f, i)) in
        (length ls) = i end
    
    fun my_count_returns_non_negative_int x xs = 
        (my_count x xs) >= 0
    
    fun rec_test rec i = 
        {theInteger = rec.theInteger, theString = rec.theString, z = i} = {rec with z = i}

    fun pre_pos x = 
        x >= 0

    fun my_floor_test i =
        my_floor i = floor i

    fun my_ceil_1_test i =
        my_ceil_1 i = ceil i
    
    fun my_ceil_2_test i =
        my_ceil_2 i = ceil i
    
    fun both_ceil_test i =
        my_ceil_1 i = my_ceil_2 i
    
    fun tup_test x y z w = x+y+z+w < 100 (* = w+z+y+x *)

    fun no_args() = true

    fun test_bad_insert xs x =
        length (bad_insert xs x) = (length xs) + 1 
    
    fun test_bad_half n = 
        n > (bad_half n)
    
    fun append_always_longer s1 s2 = 
        string_length s1 < string_length (s1 ^ s2)
    
    fun record_shrink_test r = 
        r.theInteger < 50

(* 
--------------------------------
USED FOR USERGUIDE - g
-------------------------------- 
*)
    fun filter_less ([], _) = []
    | filter_less ((x::xs), p) = 
        if x < p then append [x] (filter_less (xs, p)) else (filter_less (xs, p))

    fun filter_greater ([], _) = []
    | filter_greater ((x::xs), p) = 
        if x > p then append [x] (filter_greater (xs, p)) else (filter_greater (xs, p))


    fun my_quicksort [] = []
    | my_quicksort (x::xs) =
        let val smaller = my_quicksort(filter_less(xs, x))
            val greater = my_quicksort(filter_greater(xs, x)) in 
        append (append smaller [x]) (greater) end
    
    fun ordered [] = true
    | ordered (x::[]) = true 
    | ordered (x::y::ys) = 
        if x <= y then ordered (y::ys) else false

    fun my_sort_is_ordered xs = 
        ordered (my_quicksort xs) 
    
    fun my_sort_keep_length xs = 
        length xs = length (my_quicksort(xs))
    
    fun pre_list_size_greater_than_one xs = 
        if (length xs) <= 1 then false else true
    
    fun no_duplicates[] = true 
    | no_duplicates (x::xs) = if (elem x xs) then false else no_duplicates xs

    fun cons_length_increase xs x = 
        (length (x::xs)) = ((length xs) + 1)
(*
--------------------------------
TC^2 - z
-------------------------------- 
*)
    fun tc_sort_length_always_fails () =    
        tc [list(integer())] my_sort_keep_length = false
    
    fun tc_sort_ordered_always_true () =    
        tc [list(integer())] my_sort_is_ordered = true
in

(*
--------------------------------
ALL TESTS - x
-------------------------------- 
*)

(* shrinking tests - x *)
(* tc [list(integer()), integer()] test_bad_insert;
tc [integer()] (test_bad_half, (fn x => x >= 15)); *)
tc [string(), string()] (append_always_longer, lengths_not_same);
tc [record ["theInteger", "theString"] [integer(), string()]] record_shrink_test

(* tc^2 tests *)
(* tc [] tc_sort_ordered_always_true; *)

(* User guide tests *)
(* tc [list(integer()), integer()] cons_length_increase;
tc [list(integer())] my_sort_is_ordered;
tc [list(integer())] my_sort_keep_length;
tc [list(integer())] (my_sort_keep_length, no_duplicates); *)

(* General functionality tests *)
(* tc [(record ["theInteger", "theString"][integer(), string()]), integer()] rec_test;
tc [] no_args;
tc [integer(), integer(), integer(), integer()] tup_test;
write "\nTesting on bools commutative:";
tc [boolean(), boolean()] bool_commutative;
write "\nTesting on numbers commutative:";
tc [integer(), integer()] number_commutative;
write "\nTesting on list reverse:";
tc [list(integer())] list_reverse; 
write "\nTesting on int_gen interval:";
tc [integer()] (int_gen_stays_in_interval, pre_pos);
write "\nTesting on abs_value:";
tc  [one_of_two (integer(), float())] abs_value_is_always_pos;
write "\nTesting on my_floor:";
tc  [float()] my_floor_test; 
write "\nTesting that my_count always return non-negative result:";
tc_n [integer(), list(integer())] my_count_returns_non_negative_int 1000;
write "\nTesting my_length:";
tc [list(integer())] my_length_test;
write "\nTesting make_list:";
tc [pos_integer()] make_list_test;
write "Testing on my_ceil_1:";
tc  [float()] my_ceil_1_test;
write "Testing on my_ceil_2:";
tc  [float()] my_ceil_2_test;
write "Testing on both ceil functions:";
tc  [float()] both_ceil_test *)
end