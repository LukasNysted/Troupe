import lists

datatype Atoms = Success | Failure

(* Generates a random Number in the interval ]0;1000000000[ (Note: generates a decimal!) *)
let fun generate_number(noOfTests) = 
    let val res = if noOfTests = 0 then 0 else 
        if noOfTests = 1 then 1 else 
        if noOfTests < 10 then random()*10 else
        if noOfTests < 100 then random()*100 else
        if noOfTests < 1000 then random()*1000 else
        if noOfTests < 10000 then random()*10000 else
        if noOfTests < 100000 then random()*100000 else
        if noOfTests < 1000000 then random()*1000000 else
        if noOfTests < 10000000 then random()*10000000 else
        if noOfTests < 100000000 then random()*100000000 else
        random()*1000000000 in
    res end
        
(* Generates a random boolean *)        
    fun generate_bool() = 
        let val rnd = random()*10 
            val res =  if rnd < 5 then false
                       else true in
        res end

(* Helper function to create a list of some determined size.
    f - the function determining what to element to put into the list.
    i - the number of elements to be added to the list. *)
    fun make_list (f, i) = 
        case i of 
        0 => []
        | _ => append [f()] (make_list (f, i-1))
    
(* Generates a random list of random Numbers with size interval [0;9] *)
    fun generate_list() = 
        let val rnd = random()*10 
            val noOfItems =  if rnd < 1 then 0 else
                        if rnd < 2 then 1 else
                        if rnd < 3 then 2 else
                        if rnd < 4 then 3 else
                        if rnd < 5 then 4 else
                        if rnd < 6 then 5 else
                        if rnd < 7 then 6 else
                        if rnd < 8 then 7 else
                        if rnd < 9 then 8 else
                        9 in
        make_list (generate_number, noOfItems) end

(* Runs a property with some arguments. 
    prop - the property function to test.
    args - a list of arguments - must match number of arguments needed for the property function. *)
    fun run_test (prop, args) = 
        let val res = 
            case args of 
                [] => prop
                | (x::xs) => 
                    let val newProp = prop x in run_test(newProp, xs) end
        in res end 

(* Runs a single test and determines wether result is a Success or a Failure 
    prop - the property function to test.
    args - a list of arguments - must match number of arguments needed for the property function. *)
    fun check_success prop args =
        if run_test (prop, args) then (Success, []) else (Failure, args)

(* Runs however many tests specified on a single (Number)property, while always generating new inputs. 
    Drops further execution if a Failure is found. 
    prop - the property function to test.
    noOfArgs - number of arguments the property function takes.
    noOfTests - number of tests to be run.
    generator - the function that should be used to generate input values. *)
    fun run_all_tests (prop, noOfArgs, noOfTests, generator) =
        let val argsList = make_list (generator, noOfArgs)
            val (succRes, args) = check_success prop argsList
            val res = 
                case succRes of
                         Failure => (Failure, args)
                        | Success => 
                            case noOfTests of
                                 0 => (Success, [])
                                |_ => run_all_tests (prop, noOfArgs, noOfTests-1, generator)
        in res end
    
(* Tests a property function - by default 100 times.
    noOfArgs - number of arguemnts the property takes  
    generator - the generator function to generate inputs
    prop - the property function to test.
    (Optional) noOfTests - how many tests should be run*)
    fun tc noOfArgs generator prop = 
        let val (succRes, args) = run_all_tests (prop, noOfArgs, 100, generator) in 
            case succRes of
            Failure => let val _ = print "Failure at input: "
                                        in print args end 
            | Success => print "OK: Passed after 100 tests!"
            end
    fun tc noOfArgs generator prop noOfTests = 
        let val (succRes, args) = run_all_tests (prop, noOfArgs, noOfTests, generator) in 
            case succRes of
            Failure => let val _ = print "Failure at input: "
                                        in print args end 
            | Success => let val _ = print "OK: Passed after"
                             val _ = print noOfTests in  
                             print "tests!" end
            end
    
(* A succesful boolean property created for testing purposes 
    x,y - should be booleans *)
    fun bool_commutative x y = 
        (x andalso y) = (y andalso x)
    
(* A succesful property for numbers created for testing purposes 
    x,y - should be numbers. *)
    fun number_commutative x y = 
        x * y = y * x

(* A succesful property for lists created for testing purposes 
    xs - should be a list. *)
    fun list_reverse xs = 
        reverse(reverse xs) = xs

    val _ = print "Testing on lists:"
    val listTestRes = tc 1 generate_list list_reverse 3
    val _ = print "Testing on bools:"
    val boolTestRes = tc 2 generate_bool bool_commutative 3
    val _ = print "Testing on numbers:"
    val numberTestRes = tc 2 generate_number number_commutative 2
in print "done" end

