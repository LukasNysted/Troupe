import lists  
(* 
--------------------------------
PRINTING TO CONSOLE - q
-------------------------------- 
*)
let val out = getStdout authority
    fun write x = fwrite (out, x)
    (* arguments are always in a list - for easier readability these are removed when converting arguments to string *)
    fun args_toString args = 
        let fun aux_toString acc (x0::x1::xs) = aux_toString (acc ^ (toString x0) ^ ", ") (x1::xs)
            | aux_toString acc (x::xs) = acc ^ (toString x) in 
        aux_toString "" args end
(* 
--------------------------------
ERROR HANDLING - w
-------------------------------- 
*)
    fun report_error error_reason = 
        write "\u001B[31m \nError: "; (* Changing the print color to red *)
        let val err_string = case error_reason of 
            ("cant_generate", tries) => "Couldn't produce an instance that satisfies all strict constraints after "
                                            ^ (toString tries) ^ " tries.\n"
            | ("cant_satisfy", tries) => "No valid test could be generated after " ^ (toString tries) ^ " tries.\n"
            | ("non_boolean_result", _) => "The property or precondition code returned a non-boolean result.\n"
            | ("type_mismatch", _) => "The types' structure doesn't match the property.\n"
            | ("illegal_gen_def", _ ) => "Generator is defined wrong - use tuple() or record() to combine generators.\n"
            | ("record_mismatch", _) => "the number of names provided for record generation, does not match the number of types provided.\n"
            | ("shrinking_looped", _) => "Shrinking looped.\n"
            | ("non_string_type", _) => "An element of non-string type found when trying to convert list to string.\n"
        in
        write (err_string ^ "\u001B[0m"); (* Changing the color back *)
        exit (authority, 0) end
    
    fun boolean_check x = 
        if (getType x)<>"boolean" then report_error ("non_boolean_result", 0) else ()

    fun function_not_done_check p = 
        if (getType p)<>"function" then report_error ("type_mismatch", 0) else ()
(*
--------------------------------
UTILS - e
-------------------------------- 
*)  
    fun remove_nth n [] i = []
    | remove_nth n (x::xs) i = 
        if n = i then xs
        else x :: (remove_nth n xs (i + 1))
    
    fun make_list (f, i) = 
        case i of 
        0 => []
        | _ => append [f()] (make_list (f, i-1))
    
    fun abs_value x = 
    if x < 0 then -x else x 

(* applies the list of arguments to the property - one by one - reporting errors along the way *)
(* TODO: handle when arguments are passed to a property that does not take arguments *)
    fun apply_args p l =
        case l of 
            [] => boolean_check (p()); p() (* this case is only reached if there are no generators to beign with*)
            | (x::xs) => 
                let val res = foldl (fn (x,y) => function_not_done_check y; y x) p l in
                boolean_check res;
                res 
                end
    
    fun string_to_list s = 
        let fun aux "" acc = acc 
            | aux s acc = 
                let val x = substring (s, 0, 1)
                    val xs = substring (s, 1, 1/0) in 
                aux xs (append acc [x]) end in 
        aux s [] end
    
    fun list_to_string ls = 
        foldl (fn (x,y) => if getType x <> "string" then report_error ("non_string_type", 0) else y ^ x) "" ls
    
    fun string_length s = 
        length (string_to_list s)

    fun report_fail_reason rec noOfTests= 
        case rec.failReason of
            "false_prop" => 
                write "\nFailure at input: ";
                write (args_toString rec.ctx);
                write ("\nAfter running: " ^ (toString (noOfTests - rec.remTests + 1)) ^ " test(s)\n")
    
    fun build_record names vals = 
        let fun aux r [] [] = r 
            | aux r (n::ns) (v::vs) = 
                aux (recordExtend(r, n, v)) ns vs in
        aux {} names vals 
        end
    
    fun build_tuple ls = 
                case ls of 
                [] => (0)
                |[x] => (x) 
                |[x1,x2] => (x1,x2)
                |[x1,x2,x3] => (x1,x2,x3)
                |[x1,x2,x3,x4] => (x1,x2,x3,x4)
                |[x1,x2,x3,x4,x5] => (x1,x2,x3,x4,x5)
                |[x1,x2,x3,x4,x5,x6] => (x1,x2,x3,x4,x5,x6)
                |[x1,x2,x3,x4,x5,x6,x7] => (x1,x2,x3,x4,x5,x6,x7)
                |[x1,x2,x3,x4,x5,x6,x7,x8] => (x1,x2,x3,x4,x5,x6,x7,x8)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9] => (x1,x2,x3,x4,x5,x6,x7,x8,x9)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10] => (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
                |_ => (2, 3, 4, 5) 
(* 
--------------------------------
SHRINKING - r
-------------------------------- 
*)  

    fun rec_rng ls =
    receive [hn ("REQUEST_RND", senderid) =>
                let val rnd = floor (random()*1000000) 
                    val _ = send (senderid, rnd) 
                    in rec_rng (append ls [rnd])
                    end, 
            hn ("REQUEST_SEQ", senderid) => 
                let val _ = send (senderid, ls)
                in rec_rng []
                end]
    
    fun rep_rng ls = 
        receive [hn ("REQUEST_RND", senderid) => 
                    case ls of 
                    (x::xs) => 
                        let val _ = send (senderid, x) 
                        in rep_rng xs
                        end 
                    | [] => 
                        let val _ = send (senderid, 0)
                        in rep_rng ls 
                        end, 
                hn ("REQUEST_LEFT", senderid) => 
                    let val _ = send (senderid, ls)
                    in rep_rng [] 
                    end, 
                hn ("UPDATE_LS", new_ls) => 
                    rep_rng new_ls]

    fun dec_nth list idx = 
        let fun dec_nth_aux [] acc i = acc 
            | dec_nth_aux (x::xs) acc i =
                case i = idx of 
                true =>
                    let val dec_val = if x-1 <= 0 then 0 else floor (x/2) in
                    dec_nth_aux xs (append acc [dec_val]) (i+1) end
                | false => dec_nth_aux xs (append acc [x]) (i+1)
        in  
            dec_nth_aux list [] 0 end
    
    fun dec_all seq = 
        let fun dec_all_aux acc [] i = acc 
            | dec_all_aux acc (x::xs) i = 
                if x = 0 then
                    dec_all_aux acc xs (i+1)
                else 
                    dec_all_aux (append acc [(fn () => (dec_nth seq i))]) xs (i+1) in 
        dec_all_aux [] seq 0 end
    
    fun seqs_of_seq sequence lengths = 
        let fun aux seq acc 0 = (acc, seq) 
            | aux (x::xs) acc n = 
                aux xs (append acc [x]) (n-1) in 
        (foldl (fn (x,(acc, s)) => 
                                let val (curr_acc, curr_seq) = aux s [] x in 
                                (append acc [curr_acc], curr_seq) end)([], sequence) lengths).0 end

    fun cutoff_at list idx = 
        let fun aux ls acc 0 = acc
            | aux (x::xs) acc i = 
                aux xs (append acc [x]) (i-1) in 
        aux list [] idx end 

    fun shrink_aux seqs gens lengths prop pre size counter pid = 
        case seqs of 
        (x1::x2::xs) => 
            let val seqs_of_curr = seqs_of_seq (x2()) lengths
                val args_and_leftovers = mapi (fn (i, x) =>
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = x pid size
                                            val _ = send (pid, ("REQUEST_LEFT", self()))
                                            val left_overs = receive [hn x => x] 
                                        in (arg, left_overs)
                                        end) gens

                val (test_args, left_over_seqs) = foldl (fn (x, (raws, left_overs)) => (append raws [x.0], append left_overs [x.1])) ([],[]) args_and_leftovers
                val ret_seqs = mapi (fn (i,x) => 
                                        if (length x) = 0 then (nth seqs_of_curr (i+1)) 
                                        else cutoff_at (nth seqs_of_curr (i+1)) ((nth lengths (i+1))-(length x))) left_over_seqs
                val precond_is_met = if (pre <> ()) then (apply_args pre test_args) else true 
            in
                case (apply_args prop test_args) orelse (precond_is_met = false) of 
                true => shrink_aux (x1::xs) gens lengths prop pre size counter pid
                | false => integrated_shrink ret_seqs gens prop pre size (counter+1) pid
            end  
        | (x::xs) => 
            let val seqs_of_curr = seqs_of_seq (x()) lengths
                val test_args = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y pid size 
                                            in arg end) gens
                val precond_is_met = if (pre <> ()) then (apply_args pre test_args) else true
            in  
                case (apply_args prop test_args) orelse (precond_is_met = false) orelse (size < 0) of 
                    true => 
                        let val res = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y pid (size+1) 
                                            in arg end) gens in 
                        {shrunk_ctx = res, count = counter} end
                    | false => shrink_aux [x] gens lengths prop pre (size-1) counter pid
                
            end

    and integrated_shrink sequences gens prop pre size counter pid = 
        let val (seqs_comb, seq_lengths) = foldl (fn (x, (seq, lengths)) => ((append seq x), (append lengths [(length x)]))) ([], []) sequences
        in
            if foldl (fn (x,y) => (x = 0) andalso y) true seqs_comb then 
                shrink_aux [seqs_comb] gens seq_lengths prop pre size counter pid
            else  
                let val decreased_seqs = dec_all seqs_comb
                    val dec_seqs_w_root = append [fn() => seqs_comb] decreased_seqs
                    val res = shrink_aux dec_seqs_w_root gens seq_lengths prop pre size (counter) pid
                in 
                res end
        end
    
    fun random_shrink_aux sequences generators prop pre success size counter pid =
        if (counter = 10000) orelse (size = 0) then {count = success, size = size, sequences = sequences} else
        let val new_size = size-1
            val (shrunk_args, shrunk_sequences) = 
                                        foldl (fn (x, (arg_acc, seq_acc)) => 
                                                let val arg = x pid new_size
                                                    val _ = send (pid, ("REQUEST_SEQ", self()))
                                                    val seq = receive [hn x => x]
                                                in (append arg_acc [arg], append seq_acc [seq]) 
                                                end) ([],[]) generators
            val precond_is_met = if (pre <> ()) then (apply_args pre shrunk_args) else true 
        in
            case (apply_args prop shrunk_args) orelse (precond_is_met = false) of
                true => random_shrink_aux sequences generators prop pre success size (counter+1) pid
                | false =>
                    random_shrink_aux shrunk_sequences generators prop pre (success+1) new_size (0) pid
        end

    fun shrink sequence generators prop pre size counter = 
        let val rng_recorder = spawn (fn() => rec_rng [])
            val res = random_shrink_aux sequence generators prop pre 0 size counter rng_recorder
            val rng_replayer = spawn (fn() => rep_rng [])
        in 
        integrated_shrink (res.sequences) generators prop pre res.size (res.count) rng_replayer end 
(*
--------------------------------
GENERATORS - t
-------------------------------- 
*)  
    (* return - {raw: number, shrinker: fn {state: string, curr: number, prev: number} => ..: {state: string, curr: number, prev: number}} *)
    (* TODO: Fix shrinking towards zero -> should shrink towards lowest valid val *)
    fun float_gen (low, high) pid size = 
        let val _ = send (pid, ("REQUEST_RND", self()))
            val x = receive [hn x => x]
            val _ = send (pid, ("REQUEST_RND", self()))
            val bool_int = receive [hn x => x]
            val bool = bool_int < 1000000/2 
            val float_of_x = x/1000000
            val lInf = low = 1/0 (* check for inf *)
            val hInf = high = 1/0
            val res = 
                case (lInf, hInf) of 
                    (true, true) => if bool then float_of_x * size else -float_of_x * size
                    | (true, false) => high - (float_of_x * size) 
                    | (false, true) => low + (float_of_x * size)
                    | (false, false) => low + (float_of_x * (high-low)) 
        in res
        end
    
    fun int_gen (low, high) pid size = 
        let val res = floor (float_gen (low, high+1) pid size)
        in res
        end

    fun bool_gen pid size = 
        let val rnd = int_gen (0,1) pid size
            val res = if rnd = 0 then false
                      else true 
        in res
        end

    fun list_gen (generator) pid size = 
        let val length = (int_gen (0, size) pid size)
            val res = make_list ((fn () => generator pid size), length) 
        in res
        end

    (* NOTE: Generates only letters (upper and lower case) and numbers. *)
    (* return - {raw: char, shrinker: fn {state: string, curr: char, prev: char} => ..: {state: string, curr: char, prev: char}} *)
    fun char_gen pid size =
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val x = (int_gen (1, ((length chars)-1)) pid size)
        in nth chars x 
        end

(* NOTE: Generates only strings of letters (upper and lower case) and numbers. *)
    fun string_gen pid size = 
        let val char_ls = list_gen (char_gen) pid size
            val string = list_to_string char_ls
        in string
        end

(* NOTE: Hardcoded for tuple of up to 10 elements *)
    fun tuple_gen ts pid size = 
        let val ts_vals = map (fn x => x pid size) ts
        in build_tuple ts_vals
        end

(* 
ns: list of strings - will be used as fieldnames
ts: list of generators - used to generate values for fields 
*)    
    fun rec_gen ns ts pid size = 
        if (length ns) <> (length ts) then 
            report_error ("record_mismatch", 0)
        else 
            let val ts_vals = map (fn x => x pid size) ts
                val res = build_record ns ts_vals 
            in res
            end 


    fun generator_gen pid size = 
        let val rnd = int_gen (1,7) pid size
            val inf = 1/0
            val res = if rnd = 1 then ((fn i => int_gen (inf, inf) pid i)) else 
                      if rnd = 2 then ((fn i => bool_gen pid i)) else 
                      if rnd = 3 then ((fn i => float_gen (inf, inf) pid i)) else
                      if rnd = 4 then ((fn i => string_gen pid i)) else
                      if rnd = 5 then ((fn i => char_gen pid i)) else
                      if rnd = 6 then ((fn i => tuple_gen pid (make_list ((fn () => int_gen(inf, inf) pid i), i)) i)) else
                     ((fn i => list_gen (int_gen(inf, inf)) pid i)) in
        res end
        
(* 
--------------------------------
CORE FUNCTIONALITY - a
-------------------------------- 
*)              
    fun core_forall (generators, prop, 0, size, pre, cap, pid) = {failReason = (), ctx = (), ctx_seq = (), remTests = 0, size = size}
        |core_forall (generators, prop, i, size, pre, cap, pid) =  
            let val (args, sequences) = foldl (fn (x, (arg_acc, seq_acc)) => 
                                                let val arg = x pid size
                                                    val _ = send (pid, ("REQUEST_SEQ", self()))
                                                    val seq = receive [hn x => x]
                                                in (append arg_acc [arg], append seq_acc [seq]) 
                                                end) ([],[])generators
            in
                case pre of 
                    () => 
                        if (apply_args prop args) then (write "."; core_forall (generators, prop, i-1, size+1, pre, cap, pid))
                        else 
                            let val _ = write "!" 
                            in {failReason = "false_prop", ctx = args, ctx_seq = sequences, remTests = i, size = size} 
                            end
                    | _ => 
                        if (apply_args pre args) then 
                            if (apply_args prop args) then (write "."; core_forall (generators, prop, i-1, size+1, pre, cap, pid))
                            else 
                                let val _ = write "!" 
                                in {failReason = "false_prop", ctx = args, ctx_seq = sequences, remTests = i, size = size} 
                                end
                        else 
                        let val _ = write "x"
                        in if (size = cap) andalso (i*5 = cap) then report_error ("cant_satisfy", size)
                            else if size = cap then {failReason = (), ctx = (), ctx_seq = (), remTests = i, size = size}
                            else core_forall (generators, prop, i, size+1, pre, cap, pid) 
                        end
            end

    fun tc_n generators p noOfTests = 
        let val (prop, pre) = 
                case p of    
                    (x,y) => (x,y)
                    | x => (x, ())
            val rng_recorder = spawn (fn() => rec_rng [])
            val res = core_forall (generators, prop, noOfTests, 0, pre, (noOfTests*5), rng_recorder) in 
            case res.failReason of
                () => write ("\u001B[1m \u001B[32m \nSuccess: \u001B[0mPassed all " ^ (toString noOfTests) ^ " test(s).\n"); true
                |_ => 
                    report_fail_reason res noOfTests; 
                    write ("\u001B[1m\u001B[34mShrinking\u001B[0m:");
                    let val shrink_res = shrink res.ctx_seq generators prop pre res.size 0 in
                    write "\nFailing test case was shrunk to:\n";
                    write (args_toString shrink_res.shrunk_ctx);
                    write ("\nAfter " ^ (toString shrink_res.count) ^ " iterations.\n");
                    false
                    end
        end
    
    fun tc generator p = tc_n generator p 100

    fun troupecheck generator p noOfTests = spawn (fn() => tc_n generator p noOfTests)
    | troupecheck generator p = spawn (fn() => tc generator p)

(* 
--------------------------------
CONVENIENCE FUNCTIONS - s
-------------------------------- 
*)
    val inf = 1 / 0
    fun integer() = int_gen(inf, inf)
        | integer (h, l) = int_gen(h, l)
    
    fun pos_integer() = integer(0, inf)

    fun neg_integer() = integer(inf, -1)

    fun float() = float_gen(inf, inf)
        | float(h, l) = float_gen(h, l)

    fun pos_float() = float(0, inf)

    fun neg_float() = float(inf, 0)

    fun boolean() = bool_gen

    fun list() = list_gen(generator_gen()) 
        |list(type) = list_gen(type)

    fun string() = string_gen

    fun char() = char_gen

    fun tuple ts = tuple_gen ts
    
    fun record ns ts = rec_gen ns ts

    fun one_of ls pid = 
        let val idx = (int_gen (1, (length ls)) pid ((length ls)))
        in 
            (nth ls idx)
        end   
(* 
--------------------------------
FUNCTIONS FOR TESTING - d
-------------------------------- 
*) 
    fun my_reverse xs = 
        xs
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1

    fun my_length [] = 0
        | my_length (x::xs) = 1 + (my_length xs)

    fun my_count y [] = 0
        | my_count y (x::xs) = 
            let val z = 
                if y = x then 1 else 0 
            in 
            z + my_count y xs end 
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1
    
    fun my_ceil_1 i =
        if i > 0 then i + (1 - (i mod 1))
        else i + (1 - (i mod 1)) - 1
    
    fun my_ceil_2 i =
        if i > 0 then (my_floor i) + 1
        else if i = 0 then 0
        else (my_floor i) + 1
    
    fun bad_insert xs x = 
        if length xs < 10 then append [x] xs else
        xs

    fun one_of_two (x, y) pid size =
        let val bool = (bool_gen pid size) in
        if bool then x pid size
        else y pid size end    
    
    fun bad_half n = 
        if n > 10 then n else n/2

    fun lengths_not_same s1 s2 = 
        (string_length s1) <> (string_length s2)    
    
(*
--------------------------------
PROPERTIES FOR TESTING - f
-------------------------------- 
*)
    fun bool_commutative x y = 
        (x andalso y) = (y andalso x)
    
    fun number_commutative x y = 
        x * y <= 50

    fun list_reverse xs = 
        reverse(reverse xs) = xs
    
    fun int_gen_stays_in_interval i = 
        let val pid = spawn (fn() => rec_rng []) in 
        (integer(0, i) pid i) <= i end
    
    fun abs_value_is_always_pos i =
        abs_value i >= 0
    
    fun my_floor_test i =
        my_floor i = floor i

    fun my_length_test xs = 
        my_length xs = length xs
    
    fun make_list_test i = 
        let val pid = spawn (fn() => rec_rng [])
            val generator = generator_gen pid i
            fun f() = generator (int_gen(0, inf) pid i) 
            val ls = (make_list (f, i)) in
        (length ls) = i end
    
    fun my_count_returns_non_negative_int x xs = 
        (my_count x xs) >= 0
    
    fun rec_test rec i = 
        {theInteger = rec.theInteger, theString = rec.theString, z = i} = {rec with z = i}

    fun pre_pos x = 
        x >= 0

    fun my_floor_test i =
        my_floor i = floor i

    fun my_ceil_1_test i =
        my_ceil_1 i = ceil i
    
    fun my_ceil_2_test i =
        my_ceil_2 i = ceil i
    
    fun both_ceil_test i =
        my_ceil_1 i = my_ceil_2 i
    
    fun tup_test x y z w = x+y+z+w < 100 (* = w+z+y+x *)

    fun no_args() = true

    fun test_bad_insert xs x =
        length (bad_insert xs x) = (length xs) + 1 
    
    fun test_bad_half n = 
        n > (bad_half n)
    
    fun append_always_longer s1 s2 = 
        string_length s1 < string_length (s1 ^ s2)
    
    fun record_shrink_test r = 
        r.theInteger < 50

(* 
--------------------------------
USED FOR USERGUIDE - g
-------------------------------- 
*)
    fun filter_less ([], _) = []
    | filter_less ((x::xs), p) = 
        if x < p then append [x] (filter_less (xs, p)) else (filter_less (xs, p))

    fun filter_greater ([], _) = []
    | filter_greater ((x::xs), p) = 
        if x > p then append [x] (filter_greater (xs, p)) else (filter_greater (xs, p))


    fun my_quicksort [] = []
    | my_quicksort (x::xs) =
        let val smaller = my_quicksort(filter_less(xs, x))
            val greater = my_quicksort(filter_greater(xs, x)) in 
        append (append smaller [x]) (greater) end
    
    fun ordered [] = true
    | ordered (x::[]) = true 
    | ordered (x::y::ys) = 
        if x <= y then ordered (y::ys) else false

    fun my_sort_is_ordered xs = 
        ordered (my_quicksort xs) 
    
    fun my_sort_keep_length xs = 
        length xs = length (my_quicksort(xs))
    
    fun pre_list_size_greater_than_one xs = 
        if (length xs) <= 1 then false else true
    
    fun no_duplicates[] = true 
    | no_duplicates (x::xs) = if (elem x xs) then false else no_duplicates xs

    fun cons_length_increase xs x = 
        (length (x::xs)) = ((length xs) + 1)
(*
--------------------------------
TC^2 - z
-------------------------------- 
*)
    fun tc_sort_length_always_fails () =    
        tc [list(integer())] my_sort_keep_length = false
    
    fun tc_sort_ordered_always_true () =    
        tc [list(integer())] my_sort_is_ordered = true

(*
--------------------------------
CUSTOM TYPE PROGRAM
-------------------------------- 
*)
    fun eval exp env =
    case exp of
      ("num", n) => n
    | ("var", n) => lookup env n ("unknown variable " ^ n)
    | ("add", e1, e2) => (eval e1 env) + (eval e2 env)
    | ("sub", e1, e2) => (eval e1 env) - (eval e2 env)
    | ("mul", e1, e2) => (eval e1 env) * (eval e2 env)
    | ("div", e1, e2) => (eval e1 env) / (eval e2 env)
    | _ => print ("Error: ill defined expression"); exit (authority, 1)

    fun execute stmt env =
        case stmt of
        ("assign", var, exp) =>
            let val value = eval exp env
            in
                append [(var, value)] env
            end
        | ("print", exp) => (()(* print ("from prog: " ^ (toString (eval exp env)) *); env)

    fun interpret prog =
        let fun interpretHelper [] env = env
            | interpretHelper (stmt :: rest) env =
                let val newEnv = execute stmt env
                in
                    interpretHelper rest newEnv
                end
            val stmts = remove_nth ((length prog)-1) prog 0
            val exp = nth prog (length prog)
            val last_env = (interpretHelper stmts [])
        in
            eval exp last_env
        end
    
    fun optimize_prog prog =
        let val stmts = remove_nth ((length prog)-1) prog 0
            val exp = nth prog (length prog)
            fun optimize_exp exp =
                case exp of
                ("num", n) => ("num", n)
                | ("var", x) => ("var", x)
                | ("add", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => ("num", (n1+n2))
                                    |_ => ("add", (optimize_exp e1), (optimize_exp e2)))
                    | _ => ("add", (optimize_exp e1), (optimize_exp e2)))
                | ("sub", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => ("num", (n1-n2))
                                    |_ => ("sub", (optimize_exp e1), (optimize_exp e2)) )
                    |_ => ("sub", (optimize_exp e1), (optimize_exp e2)))
                | ("mul", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => ("num", (n1*n2))
                                    |_ => ("mul", (optimize_exp e1), (optimize_exp e2)) )
                    |_ => ("mul", (optimize_exp e1), (optimize_exp e2)))
                | ("div", e1, e2) => 
                    (case e1 of 
                    ("num", n1) => (case e2 of 
                                    ("num", n2) => if ((n1 = 0) andalso (n2 = 0)) then ("div", e1, e2) else ("num", (n1/n2))
                                    |_ => ("div", (optimize_exp e1), (optimize_exp e2)) )
                    |_ => ("div", (optimize_exp e1), (optimize_exp e2)))

            fun optimize_stmt stmt =
                case stmt of
                ("assign", var, exp) => ("assign", var, (optimize_exp exp))
                | ("print", exp) => ("print", (optimize_exp exp))
        in
            append (map optimize_stmt stmts) [optimize_exp exp]
        end 

    fun exp_gen ls nesting_level pid size = 
        let val exp_ts = 
            if nesting_level = 2 then ["num"] 
            else (if length ls = 0 then ["num", "add", "sub", "mul", "div"] 
            else ["var", "num", "add", "sub", "mul", "div"])
            val exp_type = one_of exp_ts pid
        in 
            case exp_type of 
            "num" => 
                let val value = int_gen(1, inf) pid size in
                ("num", value) end
            | "var" => 
                let val value = one_of ls pid in
                ("var", value) end 
            |"add" => 
                let val e1 = exp_gen ls (nesting_level+1) pid size 
                    val e2 = exp_gen ls (nesting_level+1) pid size
                in
                    ("add", e1, e2)
                end
            |"sub" => 
                let val e1 = exp_gen ls (nesting_level+1) pid size 
                    val e2 = exp_gen ls (nesting_level+1) pid size
                in
                    ("sub", e1, e2)
                end
            |"mul" => 
                let val e1 = exp_gen ls (nesting_level+1) pid size 
                    val e2 = exp_gen ls (nesting_level+1) pid size
                in
                    ("mul", e1, e2)
                end
            |"div" => 
                let val e1 = exp_gen ls (nesting_level+1) pid size 
                    val e2 = exp_gen ls (nesting_level+1) pid size
                in
                    ("div", e1, e2)
                end  
        end
    
    fun assign_stmt_gen ls pid size = 
        let val n = string_gen pid size 
            val exp = exp_gen ls 0 pid size 
        in
            ("assign", n, exp)
        end 
    
    fun print_stmt_gen ls pid size = 
        let val exp = exp_gen ls 0 pid size 
        in 
            ("print", exp)
        end 

    fun stmt_gen ls pid size = 
        let val stmt = one_of ["print", "assign"] pid
        in 
            case stmt of
            "assign" => 
                let val res = assign_stmt_gen ls pid size in 
                res end
            |"print" => 
                let val res = print_stmt_gen ls pid size in 
                res end
        end 
    
    fun program_gen pid size = 
        let val num_of_insts = (int_gen(0, size) pid size)
            fun prog_gen_aux env p 0 = (p, env) 
            | prog_gen_aux env p i = 
                let val stmt = stmt_gen env pid size 
                    val newEnv = if stmt.0 = "assign" then (append [stmt.1] env) else env
                in 
                    prog_gen_aux newEnv (append p [stmt]) (i-1)
                end 
            val (prog_stmts, last_env) = prog_gen_aux [] [] num_of_insts
            val last_exp = exp_gen last_env 0 pid size
            val prog = append prog_stmts [last_exp]                  
        in 
            prog
        end
    
    fun test_prog_opt prog = 
        (interpret prog) = (interpret (optimize_prog prog))
    fun test_prog_shrink prog = 
        (interpret prog) < 100
    fun for_i body 0 = body() 
    | for_i body to = body(); for_i body (to-1)

    val seq = [[267780, 689125, 203803, 618600, 22142, 181797, 268993, 783974, 286438, 440154, 781712, 459460, 962769, 482855, 159926, 418551, 984104, 173034, 540674, 927189, 212169, 718086, 733167, 861479, 102743, 728028, 756405, 33167, 172289, 326962, 170851, 63613, 658659, 592355, 200373, 681450, 464463, 768613, 97359, 366897, 55000, 954642, 56192, 93387, 705644, 488085, 826189, 891989, 524325, 313064, 412008, 797972, 892377, 369868, 883008, 361089, 787380, 821443, 346419, 250197, 301447, 111385, 402424, 327486, 119693, 135341]]
    val size = 11
in

(* integrated_shrink seq [program_gen] test_prog_shrink () size 0; *)
for_i (fn () => tc [program_gen] test_prog_shrink) 5;
(* for_i (fn() => tc [program_gen] test_prog_shrink) 50 *)
(* tc [program_gen] test_prog_shrink *)

(*
--------------------------------
ALL TESTS - x
-------------------------------- 
*)
(* tc [integer(), integer()] number_commutative *)
(* shrinking tests - x *)
(* tc [list(integer()), integer()] test_bad_insert;
tc [integer()] (test_bad_half, (fn x => x >= 15));
tc [string(), string()] (append_always_longer, lengths_not_same);
tc [record ["theInteger", "theString"] [integer(), string()]] record_shrink_test; *)

(* tc^2 tests *)
(* tc [] tc_sort_ordered_always_true; *)

(* User guide tests *)
(* tc [list(integer()), integer()] cons_length_increase;
tc [list(integer())] my_sort_is_ordered;
tc [list(integer())] my_sort_keep_length;
tc [list(integer())] (my_sort_keep_length, no_duplicates) *)

(* General functionality tests *)
(* tc [(record ["theInteger", "theString"][integer(), string()]), integer()] rec_test;
tc [] no_args;
tc [integer(), integer(), integer(), integer()] tup_test;
write "\nTesting on bools commutative:";
tc [boolean(), boolean()] bool_commutative;
write "\nTesting on numbers commutative:";
tc [integer(), integer()] number_commutative;
write "\nTesting on list reverse:";
tc [list(integer())] list_reverse; 
write "\nTesting on int_gen interval:";
tc [integer()] (int_gen_stays_in_interval, pre_pos);
write "\nTesting on abs_value:";
tc  [one_of_two (integer(), float())] abs_value_is_always_pos;
write "\nTesting on my_floor:";
tc  [float()] my_floor_test; 
write "\nTesting that my_count always return non-negative result:";
tc_n [integer(), list(integer())] my_count_returns_non_negative_int 1000;
write "\nTesting my_length:";
tc [list(integer())] my_length_test;
write "\nTesting make_list:";
tc [pos_integer()] make_list_test;
write "Testing on my_ceil_1:";
tc  [float()] my_ceil_1_test;
write "Testing on my_ceil_2:";
tc  [float()] my_ceil_2_test;
write "Testing on both ceil functions:";
tc  [float()] both_ceil_test *)
exit (authority, 0)
end