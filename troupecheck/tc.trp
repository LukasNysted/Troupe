import lists
let      
(* ----------------USED FOR PRINTING TO CONSOLE-------------------- *)
    val out = getStdout authority
    fun write x = fwrite (out, x)
    fun tc_toString x =
        case x of 
            (y, ys) => "(" ^ (tc_toString y) ^ ", " ^ (tc_toString ys) ^ ")"
            | (y::ys) => "[" ^ (tc_toString y) ^ ", " ^ (tc_toString ys) ^ "]"
            | _ => toString x
(* -----------------GENERATORS AND UTILS--------------------------*)
    val inf = 1 / 0
(* Generates a random boolean *) 
    fun bool_gen size = 
        let val rnd = random() 
            val res =  if rnd < 1/2 then false
                       else true in
        res end

(* Generates a random float based on number of tests that has been run so far. 
    (low, high) - a tuple of values specifying the interval numbers should be generated between
    size - a non negative integer*)
    fun float_gen (low, high) size = 
        let val x = random() 
            val lInf = low = inf
            val hInf = high = inf
        in 
        case (lInf, hInf) of 
            (true, true) => if (bool_gen size) then x*size else -x*size
            | (true, false) => high - (x*size) 
            | (false, true) => low + (x*size)
            | (false, false) => low + (x * (high-low))
            end

(* Generates a random integer based on number of tests that has been run so far. 
    (low, high) - a tuple of values specifying the interval numbers should be generated between
    size - a non negative integer*)
    fun int_gen (low, high) size = 
        floor (float_gen(low, high) size) 
    
(* Create a list of some determined size.
    f - the function determining what to element to put into the list.
    i - the number of elements to be added to the list. *)
    fun make_list (f, i) = 
        case i of 
        0 => []
        | _ => append [f()] (make_list (f, i-1))

(* Generates a randomly sized list of some specified type of elements.
    generator - the generator that should be used to create elements. 
    noOfTests - some non negative integer *)
    and list_gen (generator) size = 
        let val length = (int_gen(0, size) size) in
        make_list ((fn () => generator size), length) end

(* Generates a random generator *)
    fun generator_gen size = 
        let val rnd = random()
            val res = if rnd <= 1/4 then (fn i => int_gen(inf, inf) i) else 
                      if rnd <= 2/4 then (fn i => bool_gen i) else 
                      if rnd <= 3/4 then (fn i => float_gen(inf, inf) i) else
                     (fn i => list_gen (int_gen(inf, inf)) i) in
        res end


(* Copied from list lib, becuase it doesn't seem to be imported with the library?*)
    fun nth (x::l) 1 = x
      | nth (x::l) n = nth l (n - 1)

(* Generates a random character - no spaces or sepcial characters,
     only letters (upper and lower case) and numbers. *)
    fun char_gen size =
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val x = int_gen (1, ((length chars)-1)) size in 
            nth chars x end

(* Generates a random string, with length ranging from 0 to noOfTest,
     only letters (upper and lower case) and numbers. *)
    fun string_gen size = 
        let val x = int_gen (0, size) size
            fun fold f acc 0 = acc 
            | fold f acc i = fold f (acc ^ f()) (i-1) in 
        fold char_gen "" x end
    
    fun one_of_two (x, y) =
        let val bool = bool_gen 0 in
            if bool then x
            else y end
    
    fun abs_value x = 
        if x < 0 then -x else x 

(* ----------------------CORE FUNCTIONALITY--------------------------*)
(* Runs however many tests specified on a property, while always generating new inputs. 
    Drops further execution if a Failure is found. 
    prop - the property function to test.
    noOfArgs - number of arguments the property function takes.
    noOfTests - number of tests to be run.
    generator - the function that should be used to generate input values. *)
    fun core_forall (generator, prop, 0, noOfTests, pre) = (true, (), ())
        |core_forall (generator, prop, i, noOfTests, pre) =    
            let val args = generator noOfTests in
            case pre of 
                () => 
                    if prop args then core_forall (generator, prop, i-1, noOfTests+1, pre)
                    else (false, args, noOfTests) 
                | _ => 
                    if (pre args) then 
                        if (prop args) then (write "."; core_forall (generator, prop, i-1, noOfTests+1, pre))
                        else (false, args, noOfTests)
                    else (write "x"; core_forall (generator, prop, i, noOfTests+1, pre))
            end
    

(* Tests a property function - by default 100 times.
    noOfArgs - number of arguemnts the property takes  
    generator - the generator function to generate inputs
    prop - the property function to test. *)
    fun tc generator p = 
        let val (prop, pre) = 
            case p of    
                (x,y) => (x,y)
                | x => (x, ())
            val (succRes, args, successfulTests) = core_forall (generator, prop, 100, 0, pre) in 
            case succRes of
            false => write "\nFailure at input: ";
                        write (tc_toString args);
                        write ("\nAfter running: " ^ (toString (successfulTests+1)) ^ " test(s)")
            | true => write "\nOK: Passed after 100 tests!\n"
            end

(* Tests a property function a given number of times.
    generator - the generator function to generate inputs
    prop - the property function to test.
    noOfTests - how many tests should be run. *)
    fun tc_n generator prop noOfTests = 
        let val (succRes, args, successfulTests) = core_forall (generator, prop, noOfTests, 0, ()) in 
                case succRes of
                false => write "\nFailure at input: ";
                            write args;
                            write ("\nAfter running: " ^ (toString (successfulTests+1)) ^ " test(s)")
                | true => write ("\nSuccess: Passed all " ^ (toString noOfTests) ^ " test(s).\n")
                end


(* --------------------------User convenience functions -------------------------*)
    fun integer() = int_gen(inf, inf)
        | integer (h, l) = int_gen(h, l)
    
    fun pos_integer() = int_gen(0, inf)

    fun neg_integer() = int_gen(inf, 0)

    fun float() = float_gen(inf, inf)
        | float(h, l) = float_gen(h, l)

    fun pos_float() = float_gen(0, inf)

    fun neg_float() = float_gen(inf, 0)

    fun boolean() = bool_gen

    fun list() = list_gen(generator_gen)
        |list(type) = list_gen(type)

    fun string() = string_gen

    fun char() = char_gen

    fun tuple ts =
        case ts of 
            [] => (fn i => ())
            | (y::ys) => 
                let fun tuple_aux (f, []) = f 
                | tuple_aux (f, (x::xs)) = tuple_aux ((fn i => (f i, x i)), xs)
                in 
                tuple_aux ((fn i => y i), ys) end
    
(* --------------------------functions to test on-------------------------------- *) 
    fun my_reverse xs = 
        xs
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1

    fun my_length [] = 0
        | my_length (x::xs) = 1 + (my_length xs)

    fun my_count y [] = 0
        | my_count y (x::xs) = 
            let val z = 
                if y = x then 1 else 0 
            in 
            z + my_count y xs end
(* --------------------------Propterties to run-------------------------*)
    fun bool_commutative x y = 
        (x andalso y) = (y andalso x)
    
    fun number_commutative (x, y) = 
        x * y = y * x

    fun list_reverse xs = 
        reverse(reverse xs) = xs
    
    fun int_gen_stays_in_interval i = 
        int_gen (0, i) i <= i
    
    fun abs_value_is_always_pos i =
        abs_value i >= 0
    
    fun my_floor_test i =
        my_floor i = floor i

    fun my_length_test xs = 
        my_length xs = length xs
    
    fun make_list_test i = 
        length (make_list ((fn ()=> (generator_gen i) (int_gen(0,inf) i)), i)) = i
    
    fun my_count_returns_non_negative_int (x, xs) = 
        (my_count x xs) >= 0
    
    fun pre_pos x = 
        x > 3
    in

    write "\nTesting on bools commutative:";
    tc (tuple [boolean(), boolean()]) (fn(x,y) => bool_commutative x y);
    write "\nTesting on numbers commutative:";
    tc (tuple [integer(), integer()]) number_commutative;
    write "\nTesting on list reverse:";
    tc (list(integer())) list_reverse; 
    write "\nTesting on int_gen interval:";
    tc (pos_integer()) (int_gen_stays_in_interval, pre_pos);
    write "\nTesting on abs_value:";
    tc  (one_of_two (integer(), float())) abs_value_is_always_pos;
    write "\nTesting on my_floor:";
    tc  (float()) my_floor_test; 
    write "\nTesting that my_count always return non-negative result:";
    tc_n (tuple ([integer(), list(integer())])) my_count_returns_non_negative_int 1000;
    write "\nTesting my_length:";
    tc (list()) my_length_test;
    write "\nTesting make_list:";
    tc (pos_integer()) make_list_test 
    end
