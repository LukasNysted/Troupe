import lists
let      
(* ----------------USED FOR PRINTING TO CONSOLE-------------------- *)
    val out = getStdout authority
    fun write x = fwrite (out, x)
    (* arguments are always in a list - for easier readability these are removed when converting arguments to string *)
    fun args_toString args = 
        let fun aux_toString acc (x0::x1::xs) = aux_toString (acc ^ (toString x0) ^ ", ") (x1::xs)
            | aux_toString acc (x::xs) = acc ^ (toString x) in 
        aux_toString "" args end
(* -------------------------------Error Handling-------------------------------- *)
(* 
arity_limit ->
Error: Couldn't produce a function of the desired arity, please
    recompile PropEr with an increased value for ?MAX_ARITY.
 *)
    fun report_error error_reason = 
        write "\u001B[31m \nError: "; (* Changing the print color to red *)
        let val err_string = case error_reason of 
            ("cant_generate", tries) => "Couldn't produce an instance that satisfies all strict constraints after "
                                            ^ (toString tries) ^ " tries.\n"
            | ("cant_satisfy", tries) => "No valid test could be generated after " ^ (toString tries) ^ " tries.\n"
            | ("non_boolean_result", _) => "The property or precondition code returned a non-boolean result.\n"
            | ("type_mismatch", _) => "The types' structure doesn't match the property.\n"
            | ("illegal_gen_def", _ ) => "Generator is defined wrong - use tuple() or record() to combine generators.\n"
            | ("record_mismatch", _) => "the number of names provided for record generation, does not match the number of types provided.\n"
        in
        write (err_string ^ "\u001B[0m"); (* Changing the color back *)
        exit (authority, 0) end
    
(* -----------------GENERATORS AND UTILS--------------------------*)
(* Generates a random boolean *) 
    fun bool_gen size = 
        let val rnd = random() 
            val res =  if rnd < 1/2 then false
                       else true in
        res end

(* Generates a random float based on number of tests that has been run so far. *)
    fun float_gen (low, high) size = 
        let val x = random() 
            val lInf = low = 1/0 (* check for inf *)
            val hInf = high = 1/0
        in 
        case (lInf, hInf) of 
            (true, true) => if (bool_gen size) then x*size else -x*size
            | (true, false) => high - (x*size) 
            | (false, true) => low + (x*size)
            | (false, false) => low + (x * (high-low))
            end

(* Generates a random integer based on number of tests that has been run so far. *)
    fun int_gen (low, high) size = 
        floor (float_gen(low, high) size) 
    
(* Create a list of some determined size. *)
    fun make_list (f, i) = 
        case i of 
        0 => []
        | _ => append [f()] (make_list (f, i-1))

(* Generates a randomly sized list of some specified type of elements. *)
    and list_gen (generator) size = 
        let val length = (int_gen(0, size) size) in
        make_list ((fn () => generator size), length) end

(* Generates a random character - no spaces or sepcial characters,
     only letters (upper and lower case) and numbers. *)
    fun char_gen size =
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val x = int_gen (1, ((length chars)-1)) size in 
            nth chars x end

(* Generates a random string, with length ranging from 0 to size,
     only letters (upper and lower case) and numbers. *)
    fun string_gen size = 
        let val x = int_gen (0, size) size
            fun fold f acc 0 = acc 
            | fold f acc i = fold f (acc ^ f()) (i-1) in 
        fold char_gen "" x end

(* Generates a tuple *)
(* Hardcoded for tuple of up to 10 elements *)
    fun tuple_gen ts i = 
        case ts of 
            [] => (0)
            |[x] => (x) 
            |[x1,x2] => (x1,x2)
            |[x1,x2,x3] => (x1,x2,x3)
            |[x1,x2,x3,x4] => (x1,x2,x3,x4)
            |[x1,x2,x3,x4,x5] => (x1,x2,x3,x4,x5)
            |[x1,x2,x3,x4,x5,x6] => (x1,x2,x3,x4,x5,x6)
            |[x1,x2,x3,x4,x5,x6,x7] => (x1,x2,x3,x4,x5,x6,x7)
            |[x1,x2,x3,x4,x5,x6,x7,x8] => (x1,x2,x3,x4,x5,x6,x7,x8)
            |[x1,x2,x3,x4,x5,x6,x7,x8,x9] => (x1,x2,x3,x4,x5,x6,x7,x8,x9)
            |[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10] => (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
            |_ => (2, 3, 4, 5)

(* Generates a record with fields corresponding to first list of strings, and values corresponding to second list *)    
    fun rec_gen ns ts = 
        let val noOfElems = length ts 
        in if (length ns) <> noOfElems then 
            report_error ("record_mismatch", 0)
        else
            case (ns, ts) of 
            ([],[]) => (fn i => {})
            | ((y::ys), (v::vs)) => 
                let fun record_aux (f, [], []) = f 
                | record_aux (f, (x::xs), (z::zs)) = record_aux ((fn i => recordExtend((f i), x, (z i))), xs, zs)
                in 
                (record_aux ((fn i => recordExtend({}, y, (v i))), ys, vs)) end end

(* Generates a random generator *)
    fun generator_gen size = 
        let val rnd = random()
            val inf = 1/0
            val res = if rnd <= 1/7 then ((fn i => int_gen(inf, inf) i)) else 
                      if rnd <= 2/7 then ((fn i => bool_gen i)) else 
                      if rnd <= 3/7 then ((fn i => float_gen(inf, inf) i)) else
                      if rnd <= 4/7 then ((fn i => string_gen i)) else
                      if rnd <= 5/7 then ((fn i => char_gen i)) else
                      if rnd <= 6/7 then ((fn i => tuple_gen (list_gen (fn _ => int_gen(inf, inf)) i) i)) else
                     ((fn i => list_gen (int_gen(inf, inf)) i)) in
        res end
    
    fun one_of_two (x, y) =
        let val bool = bool_gen 0 in
            if bool then x
            else y end
    
    fun abs_value x = 
        if x < 0 then -x else x 


(* ----------------------CORE FUNCTIONALITY--------------------------*)
    fun arg_is_minimum_inst = 
        case getType x of  
            "list" =>  x = []
            | "number" => x = 0 
            | "boolean" => x = false 
            | "string" => x = "" 
            | "record" => false 
            | "tuple" => false
    
    fun get_shrinker arg = 
        case getType arg of  
            "list" =>  x = []
            | "number" => x = 0 
            | "boolean" => x = false 
            | "string" => x = "" 
            | "record" => false 
            | "tuple" => false

    fun arg_shrink arg = 
        case getType arg of 
                    "list" => shrink_list arg
                    | "number" => shrink_number arg
                    | "boolean" => shrink_bool arg 
                    | "string" => shrink_string arg 
                    | "record" => shrink_rec arg 
                    | "tuple" => shrink_tuple arg

    and boolean_check x = 
        if (getType x)<>"boolean" then report_error ("non_boolean_result", 0) else ()

    and function_not_done_check p = 
        if (getType p)<>"function" then report_error ("type_mismatch", 0) else ()

    and shrink_number n = 
        if n-1 <= 0 then 0 else n-1
    
    and shrink_bool n = 
        n
    
    and shrink_string n = 
        n

    and shrink_rec n = 
        n
    
    and shrink_tuple n = 
        n
    
    and shrink_list [] = [] 
    | shrink_list (x::xs) = x


    and args_shrink args = 
        let fun shrink_aux [] acc = acc
            | shrink_aux (x::xs) acc = 
                let val x_shrunk = arg_shrink x in
                append [x_shrunk] (args_shrink xs) end in 
            (shrink_aux args []) end
    
    fun args_is_minumum_insts [] = true 
    | args_is_minumum_insts (x::xs) = 
        case getType x of  
            "list" => if x = [] then args_is_minumum_insts xs else false
            | "number" => if x = 0 then args_is_minumum_insts xs else false
            | "boolean" => if x = false then args_is_minumum_insts xs else false
            | "string" => if x = "" then args_is_minumum_insts xs else false
            | "record" => false 
            | "tuple" => false


(* applies the list of arguments to the property - one by one - reporting errors along the way *)
(* TODO: handle when arguments are passed to a property that does not take arguments *)
    fun apply_args p l =
        case l of 
            [] => boolean_check (p()); p() (* this case is only reached if there are no generators to beign with*)
            | (x::xs) => 
                let val res = foldl (fn (x,y) => function_not_done_check y; y x) p l in
                boolean_check res;
                res end

    fun shrink args prop counter = 
        let val shrunk_args = args_shrink args in
        case apply_args prop shrunk_args of
            true => {shrunk_ctx = args, count = counter} 
            | false => 
                if args_is_minumum_insts shrunk_args then {shrunk_ctx = shrunk_args, count = counter} 
                else shrink shrunk_args prop (counter+1) end
            

(* Runs however many tests specified on a property, while always generating new inputs. 
    Drops further execution if a Failure is found.  *)
    fun core_forall (generator, prop, 0, size, pre, cap) = {failReason = (), cEx = (), remTests = 0}
        |core_forall (generator, prop, i, size, pre, cap) =  
            let val args = map (fn x => x size) generator in
            case pre of 
                () => 
                    if (apply_args prop args) then (write "."; core_forall (generator, prop, i-1, size+1, pre, cap))
                    else (write "!"; {failReason = "false_prop", cEx = args, remTests = i})
                | _ => 
                    if (apply_args pre args) then 
                        if (apply_args prop args) then (write "."; core_forall (generator, prop, i-1, size+1, pre, cap))
                        else {failReason = "false_prop", cEx = args, remTests = i}
                    else 
                    (write "x"; 
                    if (size = cap) andalso (i*5 = cap) then report_error ("cant_satisfy", size)
                    else if size = cap then {failReason = (), cEx = (), remTests = i}
                    else core_forall (generator, prop, i, size+1, pre, cap))
            end
    
    fun report_fail_reason rec noOfTests= 
        case rec.failReason of
            "false_prop" => write "\nFailure at input: ";
                            write (args_toString rec.cEx);
                            write ("\nAfter running: " ^ (toString (noOfTests - rec.remTests + 1)) ^ " test(s)\n")


    (* Tests a property function a given number of times. *)
    (* test tc itself - maybe by returning result *)
    fun tc_n generator p noOfTests = 
        let val (prop, pre) = 
                case p of    
                    (x,y) => (x,y)
                    | x => (x, ())
            val res = core_forall (generator, prop, noOfTests, 0, pre, (noOfTests*5)) in 
            case res.failReason of
                () => write ("\u001B[1m \u001B[32m \nSuccess: \u001B[0mPassed all " ^ (toString noOfTests) ^ " test(s).\n"); true
                |_ => 
                    let val shrink_res = shrink res.cEx prop 0 in
                    report_fail_reason res noOfTests; 
                    write "\nFailing test case was shrunk to: ";
                    write (args_toString shrink_res.shrunk_ctx);
                    write (" After " ^ (toString shrink_res.count) ^ " iterations.");
                    false
                    end
        end
(* Tests a property function 100 times. *)
    fun tc generator p = tc_n generator p 100

    fun troupecheck generator p noOfTests = spawn (fn() => tc_n generator p noOfTests)
    | troupecheck generator p = spawn (fn() => tc generator p)

(* --------------------------User convenience functions -------------------------*)
    val inf = 1 / 0
    fun integer() = int_gen(inf, inf)
        | integer (h, l) = int_gen(h, l)
    
    fun pos_integer() = int_gen(0, inf)

    fun neg_integer() = int_gen(inf, -1)

    fun float() = float_gen(inf, inf)
        | float(h, l) = float_gen(h, l)

    fun pos_float() = float_gen(0, inf)

    fun neg_float() = float_gen(inf, 0)

    fun boolean() = bool_gen

    fun list() = list_gen(generator_gen())
        |list(type) = list_gen(type)

    fun string() = string_gen

    fun char() = char_gen

    fun tuple ts = tuple_gen ts
        
    
    fun record ns ts = rec_gen ns ts
        
    
(* --------------------------functions to test on-------------------------------- *) 
    fun my_reverse xs = 
        xs
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1

    fun my_length [] = 0
        | my_length (x::xs) = 1 + (my_length xs)

    fun my_count y [] = 0
        | my_count y (x::xs) = 
            let val z = 
                if y = x then 1 else 0 
            in 
            z + my_count y xs end 
    
    fun my_floor i =
        if i >=0 then i - (i mod 1)
        else i - (i mod 1) - 1
    
    fun my_ceil_1 i =
        if i > 0 then i + (1 - (i mod 1))
        else i + (1 - (i mod 1)) - 1
    
    fun my_ceil_2 i =
        if i > 0 then (my_floor i) + 1
        else if i = 0 then 0
        else (my_floor i) + 1
(* --------------------------Propterties to run-------------------------*)
    fun bool_commutative x y = 
        (x andalso y) = (y andalso x)
    
    fun number_commutative x y = 
        x * y = y * x

    fun list_reverse xs = 
        reverse(reverse xs) = xs
    
    fun int_gen_stays_in_interval i = 
        int_gen (0, i) i <= i
    
    fun abs_value_is_always_pos i =
        abs_value i >= 0
    
    fun my_floor_test i =
        my_floor i = floor i

    fun my_length_test xs = 
        my_length xs = length xs
    
    fun make_list_test i = 
        length (make_list ((fn () => (generator_gen i) (int_gen(0,inf) i)), i)) = i
    
    fun my_count_returns_non_negative_int x xs = 
        (my_count x xs) >= 0
    
    fun rec_test rec i = 
        {theInteger = rec.theInteger, theString = rec.theString, z = i} = {rec with z = i}

    fun pre_pos x = 
        x >= 0

    fun my_floor_test i =
        my_floor i = floor i

    fun my_ceil_1_test i =
        my_ceil_1 i = ceil i
    
    fun my_ceil_2_test i =
        my_ceil_2 i = ceil i
    
    fun both_ceil_test i =
        my_ceil_1 i = my_ceil_2 i
    
    fun tup_test x y = x+y < 100 (* = w+z+y+x *)

    fun no_args() = true
(* ----------------------------For the userguide------------------------------- *)
    fun filter_less ([], _) = []
    | filter_less ((x::xs), p) = 
        if x < p then append [x] (filter_less (xs, p)) else (filter_less (xs, p))

    fun filter_greater ([], _) = []
    | filter_greater ((x::xs), p) = 
        if x > p then append [x] (filter_greater (xs, p)) else (filter_greater (xs, p))


    fun my_quicksort [] = []
    | my_quicksort (x::xs) =
        let val smaller = my_quicksort(filter_less(xs, x))
            val greater = my_quicksort(filter_greater(xs, x)) in 
        append (append smaller [x]) (greater) end
    
    fun ordered [] = true
    | ordered (x::[]) = true 
    | ordered (x::y::ys) = 
        if x <= y then ordered (y::ys) else false

    fun my_sort_is_ordered xs = 
        ordered (my_quicksort xs) 
    
    fun my_sort_keep_length xs = 
        length xs = length (my_quicksort(xs))
    
    fun pre_list_size_greater_than_one xs = 
        if (length xs) <= 1 then false else true
    
    fun no_duplicates[] = true 
    | no_duplicates (x::xs) = if (elem x xs) then false else no_duplicates xs

    fun cons_length_increase xs x = 
        (length (x::xs)) = ((length xs) + 1)
(* ----------------------------For tc^2---------------------------------------- *)
    fun tc_sort_length_always_fails () =    
        tc [list(integer())] my_sort_keep_length = false
    
    fun tc_sort_ordered_always_true () =    
        tc [list(integer())] my_sort_is_ordered = true
in

tc [integer(), integer()] tup_test
(* (* tc^2 tests *)
troupecheck [] tc_sort_ordered_always_true *)
(* User guide tests *)
(* tc [(record ["theInteger", "theString"][integer(), string()]), integer()] rec_test;
tc [list(integer()), integer()] cons_length_increase;
tc [list(integer())] my_sort_is_ordered;
tc [list(integer())] my_sort_keep_length;
tc [list(integer())] (my_sort_keep_length, no_duplicates);
(* General functionality tests *)
tc [] no_args;
tc [integer(), integer(), integer(), integer()] tup_test;
write "\nTesting on bools commutative:";
tc [boolean(), boolean()] bool_commutative;
write "\nTesting on numbers commutative:";
tc [integer(), integer()] number_commutative;
write "\nTesting on list reverse:";
tc [list(integer())] list_reverse; 
write "\nTesting on int_gen interval:";
tc [integer()] (int_gen_stays_in_interval, pre_pos);
write "\nTesting on abs_value:";
tc  [one_of_two (integer(), float())] abs_value_is_always_pos;
write "\nTesting on my_floor:";
tc  [float()] my_floor_test; 
write "\nTesting that my_count always return non-negative result:";
tc_n [integer(), list(integer())] my_count_returns_non_negative_int 1000;
write "\nTesting my_length:";
tc [list()] my_length_test;
write "\nTesting make_list:";
tc [pos_integer()] make_list_test;
write "Testing on my_ceil_1:";
tc  [float()] my_ceil_1_test;
write "Testing on my_ceil_2:";
tc  [float()] my_ceil_2_test;
write "Testing on both ceil functions:";
tc  [float()] both_ceil_test *)
end

(*
-----------------------------------------
 Code that may need to beused later. 
-----------------------------------------
 *)

 (* fun le tup = 
        case tup of 
        (inf, _) => true 
        | (_, inf) => true
        | (a,b) => a <= b 
    
    fun find_limit x low high fallback =
        case (le(low, x)) andalso (le(x, high)) of 
        true => x 
        |false => fallback
    
    fun sign x = 
        if x > 0 then 1 
        else if x < 0 then -1
        else 0

    fun find_target x low high =
        case (le(low,0), le(0,high)) of 
        (false, _) => 
            let val limit = find_limit(x, low, high, high) in
	        (low, fn y => y + 1, fn y => y > limit) end
	    | (true,false) =>
	        let val limit = find_limit(x, low, high, low) in 
	        (high, fn y => y - 1, fn y => y < limit) end
	    | (true,true) =>
	        let val sign = sign x 
	            val overLimit =
		            case x >= 0 of
		            true => 
                        let val limit = find_limit(x, low, high, high) in 
			            fn y => y > limit end
		            | false =>
			            let val limit = find_limit(x, low, high, low) in 
			            fn y => y < Limit end in 
	        (0, fn y => y + sign, overLimit) end
    
    fun number_shrinker x low high action = 
        case action.0 of 
        "init" => 
            let val (target, inc, overLimit) = find_target x low high in 
            case x = target of 
            true => ([], "done")
            | false => ([target], ("inc", target, inc, overLimit)) end
        | "inc" => 
            let val (last, inc, overLimit) = (action.1, action.2, action.3)  
                val newLast = inc last in
            case overLimit newLast of
	        true => ([], "done")
	        | false => ([newLast], ("inc", newLast, inc, overLimit)) end
        | "shrunk" => 
            ([], "done")

    fun get_shrinker arg = 
        number_shrinker *)
