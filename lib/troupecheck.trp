import lists

(*
-------------------------------- 
INIT FUNCTION

To be called when  starting out testing

--------------------------------
*)
let fun init_tc auth rng =  
        receive [hn ("REQUEST_RNG", senderid) => 
                    let val _ = send (senderid, rng) 
                    in init_tc auth rng end,

                hn ("REQUEST_AUTH", senderid) => 
                    let val _ = send (senderid, auth) 
                    in init_tc auth rng end,

                hn ("UPDATE_RNG", senderid, new_rng) => 
                    let val _ = send(senderid, "done") in
                    init_tc auth new_rng end]

(* 
--------------------------------
PRINTING TO CONSOLE

Simple functions for more convenient printing to console.

-------------------------------- 
*)  
    fun write x auth =
        fwrite ((getStdout auth), x)

    fun args_toString args = 
        let fun aux_toString acc (x0::x1::xs) = aux_toString (acc ^ (toString x0) ^ ", ") (x1::xs)
            | aux_toString acc (x::xs) = acc ^ (toString x) in 
        aux_toString "" args end

(* 
--------------------------------
ERROR HANDLING

Handles the printing of appropriate error messages for errors that may occur in the use of TroupeCheck.

-------------------------------- 
*)
    fun report_error error_reason tco = 
        let val _ = send (tco, ("REQUEST_AUTH", self()))
            val auth = receive [hn x => x]
            val err_string = case error_reason of 
            ("cant_generate", tries) => "Couldn't produce an instance that satisfies all strict constraints after "
                                            ^ (toString tries) ^ " tries.\n"
            | ("cant_satisfy", tries) => "No valid test could be generated after " ^ (toString tries) ^ " tries.\n"
            | ("non_boolean_result", _) => "The property or precondition code returned a non-boolean result.\n"
            | ("type_mismatch", _) => "The types' structure doesn't match the property.\n"
            | ("illegal_gen_def", _ ) => "Generator is defined wrong - use tuple() or record() to combine generators.\n"
            | ("record_mismatch", _) => "the number of names provided for record generation, does not match the number of types provided.\n"
            | ("shrinking_looped", _) => "Shrinking looped.\n"
            | ("non_string_type", _) => "An element of non-string type found when trying to convert list to string.\n"
        in
        write "\u001B[31m \nError: " auth; (* Changing the print color to red *)
        write (err_string ^ "\u001B[0m") auth; (* Changing the color back *)
        exit (auth, 0) end
    
    fun boolean_check x tco = 
        if (getType x)<>"boolean" then report_error ("non_boolean_result", 0) tco else ()

    fun function_not_done_check p tco = 
        if (getType p)<>"function" then report_error ("type_mismatch", 0) tco else ()
(*
--------------------------------
UTILS

Different utility functions that are used across the library.

-------------------------------- 
*)  
    fun remove_nth n [] i = []
    | remove_nth n (x::xs) i = 
        if n = i then xs
        else x :: (remove_nth n xs (i + 1))
    
    fun divide_list_work f length num_workers = 
        let fun make_infols acc 1 = append acc [(length - (floor(length/num_workers) * (num_workers-1)))]
            | make_infols acc i = 
                make_infols (append acc [floor(length/num_workers)]) (i-1)
            val infols = make_infols [] num_workers
            val _ = map (fn x => spawn(fn()=> f x)) infols 
            val res = foldl (fn (_,y) => let val res = receive[hn x => x] in append res y end)[] infols in 
        res end

    fun make_list (f, i) = 
        let fun make_ls_aux (f_aux, n)= 
            case n of 
                0 => []
                | _ => append [f_aux()] (make_ls_aux (f_aux, n-1))
            val self_id = self()
            fun func (l) = let val res = make_ls_aux (f, l) in send (self_id, (res)) end
            val res = divide_list_work func i 4
        in res 
        end
    
    fun abs_value x = 
    if x < 0 then -x else x 

(* TODO: handle when arguments are passed to a property that does not take arguments *)
    fun apply_args p l tco =
        case l of 
            [] => boolean_check (p()) tco; p() (* this case is only reached if there are no generators to begin with *)
            | (x::xs) => 
                let val res = foldl (fn (x,y) => function_not_done_check y tco; y x) p l in
                boolean_check res tco;
                res 
                end
    
    fun string_to_list s = 
        let fun aux "" acc = acc 
            | aux s acc = 
                let val x = substring (s, 0, 1)
                    val xs = substring (s, 1, 1/0) in 
                aux xs (append acc [x]) end in 
        aux s [] end
    
    (* Combines a list of individual strings to a single string *)
    fun list_to_string ls tco = 
        foldl (fn (x,y) => if getType x <> "string" then report_error ("non_string_type", 0) tco else y ^ x) "" ls
    
    fun string_length s = 
        length (string_to_list s)

    fun report_fail_reason rec noOfTests tco =
        let val _ = send (tco, ("REQUEST_AUTH", self()))
            val auth = receive [hn x => x] in
        case rec.failReason of
            "false_prop" => 
                write "\nFailure at input: " auth;
                write (args_toString rec.ctx) auth;
                write ("\nAfter running: " ^ (toString (noOfTests - rec.remTests + 1)) ^ " test(s)\n") auth
        end
    
    fun build_record names vals = 
        let fun aux r [] [] = r 
            | aux r (n::ns) (v::vs) = 
                aux (recordExtend(r, n, v)) ns vs in
        aux {} names vals 
        end
    
    (* Hardcoded until a tuple from list function is implemented in Troupe - an issue has been raised on GH.*)
    fun build_tuple ls = 
                case ls of 
                [] => (0)
                |[x] => (x) 
                |[x1,x2] => (x1,x2)
                |[x1,x2,x3] => (x1,x2,x3)
                |[x1,x2,x3,x4] => (x1,x2,x3,x4)
                |[x1,x2,x3,x4,x5] => (x1,x2,x3,x4,x5)
                |[x1,x2,x3,x4,x5,x6] => (x1,x2,x3,x4,x5,x6)
                |[x1,x2,x3,x4,x5,x6,x7] => (x1,x2,x3,x4,x5,x6,x7)
                |[x1,x2,x3,x4,x5,x6,x7,x8] => (x1,x2,x3,x4,x5,x6,x7,x8)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9] => (x1,x2,x3,x4,x5,x6,x7,x8,x9)
                |[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10] => (x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
                |_ => (2, 3, 4, 5) 
    
        fun dec_nth list idx = 
        let fun dec_nth_aux [] acc i = acc 
            | dec_nth_aux (x::xs) acc i =
                case i = idx of 
                true =>
                    let val dec_val = if x <= 1/1000000 then 0 else x/2 in
                    dec_nth_aux xs (append acc [dec_val]) (i+1) end
                | false => dec_nth_aux xs (append acc [x]) (i+1)
        in  
            dec_nth_aux list [] 0 end
    
    fun dec_all seq = 
        let fun dec_all_aux [] i = [] 
            | dec_all_aux (x::xs) i = 
                if x = 0 then
                    dec_all_aux xs (i+1)
                else 
                    append  [(fn () => (dec_nth seq i))] [fn () => dec_all_aux xs (i+1)] in 
        dec_all_aux seq 0 end
    
    fun seqs_of_seq sequence lengths = 
        let fun aux seq acc 0 = (acc, seq) 
            | aux (x::xs) acc n = 
                aux xs (append acc [x]) (n-1) 
            val (res, _) = (foldl (fn (x,(acc, s)) => 
                                let val (curr_acc, curr_seq) = aux s [] x in 
                                (append acc [curr_acc], curr_seq) end)([], sequence) lengths)
        in res 
        end

    fun cutoff_at list idx = 
        let fun aux ls acc 0 = acc
            | aux (x::xs) acc i = 
                aux xs (append acc [x]) (i-1) in 
        aux list [] idx end 
    
    fun for_i body 0 = body() 
    | for_i body to = body(); for_i body (to-1)
(* 
--------------------------------
SHRINKING

Works by first using random shrinking when a failing example has been found (shrink & random_shrink_aux). 
Random shrinking means simply generating new test cases with gradually smaller size, to find a case smaller than the original one. This rarely produces a minmal result.
The smallest randomly shrunk instance is then further shrunk using integrated shrinking. (integrated_shrink & shrink_aux)
Integrated shrinking means keeping track of all random decision made during generation, and then re-generating with smaller "random" decisions.

This part of the code also contains the functionality for recording all random decisions, and replaying these random decisions (produce_rng, rc_rng & rep_rng).
All of these functions are spawned and then requests or updates may be send to them, so that the correct RNG's are used at different points in the code.

-------------------------------- 
*)  
    fun produce_rng rng = 
        receive [hn ("REQUEST_RNG", senderid) => 
                    let val _ = send (senderid, rng) 
                    in produce_rng rng end,
                
                hn ("UPDATE_RNG", senderid, new_rng) => 
                    let val _ = send(senderid, "done") in
                    produce_rng new_rng end]

    fun rec_rng ls =
        receive [hn ("REQUEST_RND", senderid) =>
                    let val rnd = random()
                        val _ = send (senderid, rnd) 
                        in rec_rng (append ls [rnd])
                        end, 
                hn ("REQUEST_SEQ", senderid) => 
                    let val _ = send (senderid, ls)
                    in rec_rng []
                    end]
    
    fun rep_rng ls = 
        receive [hn ("REQUEST_RND", senderid) => 
                    case ls of 
                    (x::xs) => 
                        let val _ = send (senderid, x) 
                        in rep_rng xs
                        end 
                    | [] => 
                        let val _ = send (senderid, 0)
                        in rep_rng ls 
                        end, 
                hn ("REQUEST_LEFT", senderid) => 
                    let val _ = send (senderid, ls)
                    in rep_rng [] 
                    end, 
                hn ("UPDATE_LS", new_ls) => 
                    rep_rng new_ls]

    fun shrink_aux seqs gens lengths prop pre size counter tco = 
        let val _ = send(tco, ("REQUEST_RNG", self())) 
            val pid = receive [hn x => x]
        in case seqs of 
        (x1::x2::x3::xs) => 
            let val seqs_of_curr = seqs_of_seq (x2()) lengths
                val args_and_leftovers = mapi (fn (i, x) =>
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = x tco size
                                            val _ = send (pid, ("REQUEST_LEFT", self()))
                                            val left_overs = receive [hn x => x] 
                                        in {arg = arg, left_overs = left_overs}
                                        end) gens

                val (test_args, left_over_seqs) = foldl (fn (x, (raws, left_overs)) => (append raws [x.arg], append left_overs [x.left_overs])) ([],[]) args_and_leftovers
                val ret_seqs = mapi (fn (i,x) => 
                                        if (length x) = 0 then (nth seqs_of_curr (i+1)) 
                                        else cutoff_at (nth seqs_of_curr (i+1)) ((nth lengths (i+1))-(length x))) left_over_seqs
                val precond_is_met = if (pre <> ()) then (apply_args pre test_args tco) else true 
            in
                case (apply_args prop test_args tco) orelse (precond_is_met = false) of 
                true => shrink_aux (x1::x3()) gens lengths prop pre size counter tco
                | false => integrated_shrink ret_seqs gens prop pre size (counter+1) tco
            end  
        | (x::xs) => 
            let val seqs_of_curr = seqs_of_seq (x()) lengths
                val test_args = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y tco size 
                                            in arg end) gens
                val precond_is_met = if (pre <> ()) then (apply_args pre test_args tco) else true
            in  
                case (apply_args prop test_args tco) orelse (precond_is_met = false) orelse (size < 0) of 
                    true => 
                        let val res = mapi (fn (i, y) => 
                                        let val _ = send (pid, ("UPDATE_LS", (nth seqs_of_curr (i+1))))
                                            val arg = y tco (size+1) 
                                            in arg end) gens in 
                        {shrunk_ctx = res, count = counter} end
                    | false => shrink_aux [x] gens lengths prop pre (size-1) counter tco
                
            end 
        end

    and integrated_shrink sequences gens prop pre size counter tco = 
        let val (seqs_comb, seq_lengths) = foldl (fn (x, (seq, lengths)) => ((append seq x), (append lengths [(length x)]))) ([], []) sequences
        in
            if foldl (fn (x,y) => (x = 0) andalso y) true seqs_comb then 
                shrink_aux [seqs_comb] gens seq_lengths prop pre size counter tco
            else  
                let val decreased_seqs = dec_all seqs_comb
                    val dec_seqs_w_root = append [fn() => seqs_comb] decreased_seqs
                    val res = shrink_aux dec_seqs_w_root gens seq_lengths prop pre size (counter) tco
                in 
                res end
        end
    
    fun random_shrink_aux sequences generators prop pre success size counter divi tco =
        if (counter = 1000) orelse (size = 0) then {count = success, size = size, sequences = sequences} else
        let val _ = send(tco, ("REQUEST_RNG", self()))
            val pid = receive [hn x => x]
            val new_size = floor (size/divi)
            val (shrunk_args, shrunk_sequences) = 
                                        foldl (fn (x, (arg_acc, seq_acc)) => 
                                                let val arg = x tco new_size
                                                    val _ = send (pid, ("REQUEST_SEQ", self()))
                                                    val seq = receive [hn x => x]
                                                in (append arg_acc [arg], append seq_acc [seq]) 
                                                end) ([],[]) generators
            val precond_is_met = if (pre <> ()) then (apply_args pre shrunk_args tco) else true 
        in
            case (apply_args prop shrunk_args tco) orelse (precond_is_met = false) of
                true => random_shrink_aux sequences generators prop pre success size (counter+1) (divi+2) tco
                | false =>
                    random_shrink_aux shrunk_sequences generators prop pre (success+1) new_size (0) 2 tco
        end

    fun shrink sequence generators prop pre size counter tco = 
        let val rng_recorder = spawn (fn() => rec_rng [])
            val _ = send (tco, ("UPDATE_RNG", self(), rng_recorder))
            val _ = receive [hn x => ()]
            val res = random_shrink_aux sequence generators prop pre 0 size counter 2 tco
            val rng_replayer = spawn (fn() => rep_rng [])
            val _ = send (tco, ("UPDATE_RNG", self(), rng_replayer))
            val _ = receive [hn x => ()]
        in 
        integrated_shrink (res.sequences) generators prop pre res.size (res.count) tco end 
(*
--------------------------------
GENERATORS

Contains generators for Troupe's built-in types. All generators must return a single instance of the type they generate, 
and take a 'size' argument as the very last argument.
This size will be given to all generators in the generation of test cases (and shrinking).
Generators that take more arguments, will need to have these passed along to them before passing the generator to the testing facilities
(convenience functions for this are supplied later). 

It is recommended that all user defined generators only make use of pre-defined generators or their matching convenience functions
for random decisions (i.e. a call to float_gen/float() or int_gen/integer()), instead of having to send and receive the correct messages to the RNG threads.
However, it can be done if the users wishes to and understands what is going on.

-------------------------------- 
*)  
    fun float_gen (low, high) tco size = 
        let val _ = send (tco, ("REQUEST_RNG", self()))
            val pid = receive [hn x => x]
            
            val _ = send (pid, ("REQUEST_RND", self()))
            val x = receive [hn x => x]

            val _ = send (pid, ("REQUEST_RND", self()))
            val bool_int = receive [hn x => x]
            
            val bool = bool_int < (1/2) 
            (* val float_of_x = x/1000000 *)

            val lInf = low = 1/0 (* check for inf *)
            val hInf = high = 1/0

            val res = 
                case (lInf, hInf) of 
                    (true, true) => if bool then x * size else -x * size
                    | (true, false) => high - (x * size) 
                    | (false, true) => low + (x * size)
                    | (false, false) => low + (x * (high-low)) 
        in res
        end
    
    fun int_gen (low, high) tco size = 
        let val res = floor (float_gen (low, high+1) tco size)
        in res
        end

    fun bool_gen tco size = 
        let val rnd = int_gen (0,1) tco size
            val res = if rnd = 0 then false
                      else true 
        in res
        end

    fun list_gen (generator) tco size = 
        let val length = (int_gen (0, size) tco size)
            val res = make_list ((fn () => generator tco size), length) 
        in res
        end

    (* NOTE: Generates only letters (upper and lower case) and numbers. *)
    fun char_gen tco size =
        let val chars = 
            ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
            val x = (int_gen (1, ((length chars)-1)) tco size)
        in nth chars x 
        end

    (* NOTE: Generates only strings of letters (upper and lower case) and numbers. *)
    fun string_gen tco size = 
        let val char_ls = list_gen (char_gen) tco size
            val string = list_to_string char_ls tco
        in string
        end

    (* ts: list of generators - used to generate values for fields *)
    (* NOTE: Hardcoded for tuple of up to 10 elements  - see build_tuple in 'UTILS' *)
    fun tuple_gen ts tco size = 
        let val ts_vals = map (fn x => x tco size) ts
        in build_tuple ts_vals
        end

    (* ns: list of strings - will be used as fieldnames *)
    (* ts: list of generators - used to generate values for fields *)    
    fun rec_gen ns ts tco size = 
        if (length ns) <> (length ts) then 
            report_error ("record_mismatch", 0) tco
        else  
            let val ts_vals = map (fn x => x tco size) ts
                val res = build_record ns ts_vals 
            in res
            end 

    (* TODO: needs to be completed... *)
    fun generator_gen tco size = 
        let val rnd = int_gen (1,7) size
            val inf = 1/0
            val res = if rnd = 1 then ((fn i => int_gen (inf, inf) tco i)) else 
                      if rnd = 2 then ((fn i => bool_gen tco i)) else 
                      if rnd = 3 then ((fn i => float_gen (inf, inf) tco i)) else
                      if rnd = 4 then ((fn i => string_gen tco i)) else
                      if rnd = 5 then ((fn i => char_gen tco i)) else
                      if rnd = 6 then ((fn i => tuple_gen (make_list ((fn () => int_gen(inf, inf) tco i), i)) tco i)) else
                     ((fn i => list_gen (int_gen(inf, inf)) tco i)) in
        res end
        
(* 
--------------------------------
CORE FUNCTIONALITY

Handles running the tests (core_forall), shrinking, preparing the recorder RNG and reporting the results to the user (tc).

-------------------------------- 
*)              
    fun core_forall (generators, prop, 0, size, pre, cap, tco) = {failReason = (), ctx = (), ctx_seq = (), remTests = 0, size = size}
        |core_forall (generators, prop, i, size, pre, cap, tco) =  
            let val _ = send(tco, ("REQUEST_RNG", self()))
                val pid = receive [hn x => x]
                val _ = send(tco, ("REQUEST_AUTH", self()))
                val auth = receive [hn x => x]
                val (args, sequences) = foldl (fn (x, (arg_acc, seq_acc)) => 
                                                let val arg = x tco size
                                                    val _ = send (pid, ("REQUEST_SEQ", self()))
                                                    val seq = receive [hn x => x]
                                                in (append arg_acc [arg], append seq_acc [seq]) 
                                                end) ([],[])generators
            in
                case pre of 
                    () => 
                        if (apply_args prop args tco) then (write "." auth; core_forall (generators, prop, i-1, size+1, pre, cap, tco))
                        else 
                            let val _ = write "!" auth
                            in {failReason = "false_prop", ctx = args, ctx_seq = sequences, remTests = i, size = size} 
                            end
                    | _ => 
                        if (apply_args pre args tco) then 
                            if (apply_args prop args tco) then (write "." auth; core_forall (generators, prop, i-1, size+1, pre, cap, tco))
                            else 
                                let val _ = write "!" auth
                                in {failReason = "false_prop", ctx = args, ctx_seq = sequences, remTests = i, size = size} 
                                end
                        else 
                        let val _ = write "x" auth
                        in if (size = cap) andalso (i*5 = cap) then report_error ("cant_satisfy", size) tco
                            else if size = cap then {failReason = (), ctx = (), ctx_seq = (), remTests = i, size = size}
                            else core_forall (generators, prop, i, size+1, pre, cap, tco) 
                        end
            end

    fun run_tests (generators, p, to_shrink, noOfTests) auth = 
        let val (prop, pre) = 
                case p of    
                    (x,y) => (x,y)
                    | x => (x, ())
            val rng_recorder = spawn (fn() => rec_rng [])
            val tco = spawn (fn() => init_tc auth rng_recorder)
            val res = core_forall (generators, prop, noOfTests, 0, pre, (noOfTests*5), tco) in 
            case res.failReason of
                () => write ("\u001B[1m \u001B[32m \nSuccess: \u001B[0mPassed all " ^ (toString noOfTests) ^ " test(s).\n") auth; true
                |_ => 
                    report_fail_reason res noOfTests tco; 
                    if to_shrink then 
                        (write ("\u001B[1m\u001B[34mShrinking\u001B[0m:") auth;
                        let val shrink_res = shrink res.ctx_seq generators prop pre res.size 0 tco in
                        write "\nFailing test case was shrunk to:\n" auth;
                        write (args_toString shrink_res.shrunk_ctx) auth;
                        write ("\nAfter " ^ (toString shrink_res.count) ^ " iterations.\n") auth;
                        false
                        end)
                    else 
                        false
        end

    fun for_all (generators, p) auth = run_tests (generators, p, true, 100) auth 
    | for_all (generators, p, noOfTests) auth = run_tests (generators, p, true, noOfTests) auth 

    fun for_all_noshrink (generators, p) auth = run_tests (generators, p, false, 100) auth 
    | for_all_noshrink (generators, p, noOfTests) auth = run_tests (generators, p, false, noOfTests) auth 

    fun troupecheck props auth = 
        let val n = toString (length props)
            fun troupecheck_aux [] i = exit (auth, 0)
            | troupecheck_aux (x::xs) i =
                let val _ = write ("\nRunning test " ^ (toString i) ^ " of " ^ n ^ ":\n") auth
                    val self_id = self()
                    val _ = spawn (fn () => let val _ = (x() auth) in send(self_id, "done") end )
                    val _ = receive [hn x => ()] 
                in troupecheck_aux xs (i+1) end
        in troupecheck_aux props 1 
        end

(* 
--------------------------------
CONVENIENCE FUNCTIONS 

These are functions that make it easier for the user to make use of the different generators, and define their own generators.

-------------------------------- 
*)
    val inf = 1 / 0
    fun integer () = int_gen(inf, inf)
        | integer (h, l) = int_gen(h, l)
    
    fun pos_integer () = integer(0, inf)

    fun neg_integer () = integer(inf, -1)

    fun float () = float_gen(inf, inf)
        | float (h, l) = float_gen(h, l)

    fun pos_float () = float(0, inf)

    fun neg_float () = float(inf, 0)

    fun boolean () = bool_gen

    fun list () = list_gen(generator_gen()) 
        |list (type) = list_gen(type)

    fun string () = string_gen

    fun char () = char_gen

    fun generator() = generator_gen

    fun tuple ts = tuple_gen ts
    
    fun record ns ts = rec_gen ns ts

    fun one_of ls = 
        let val idx = (int_gen (1, (length ls)) ((length ls)))
        in 
            (nth ls idx)
        end   
in 
    [ ("make_list", make_list)
    , ("build_record", build_record)
    , ("build_tuple", build_tuple)
    , ("for_all", for_all)
    , ("for_all_noshrink", for_all_noshrink)
    , ("troupecheck", troupecheck)
    , ("inf", inf)
    , ("integer", integer)
    , ("pos_integer", pos_integer)
    , ("neg_integer", neg_integer)
    , ("float", float)
    , ("pos_float", pos_float)
    , ("neg_float", neg_float)
    , ("boolean", boolean)
    , ("list", list)
    , ("string", string)
    , ("char", char)
    , ("generator", generator)
    , ("tuple", tuple)
    , ("record", record)
    , ("one_of", one_of)
    ]
end
